# Development Guide

## Overview

This guide provides comprehensive information for developers working on the e-commerce platform, including setup, architecture, coding standards, and best practices.

## Development Environment Setup

### Prerequisites

- **Go 1.24+**: Download from [golang.org](https://golang.org/dl/)
- **PostgreSQL 14+**: Database server
- **Redis 6+**: Caching and session storage
- **Docker & Docker Compose**: For containerized services
- **Node.js 18+**: For frontend development (if applicable)
- **Git**: Version control
- **Make**: Build automation

### Local Development Setup

1. **Clone the Repository**
   ```bash
   git clone https://github.com/thanhphuocnguyen/go-eshop.git
   cd go-eshop/server
   ```

2. **Install Dependencies**
   ```bash
   go mod tidy
   ```

3. **Environment Configuration**
   ```bash
   cp app.env.example app.env
   # Edit app.env with your configuration
   ```

4. **Start Dependencies**
   ```bash
   docker-compose up -d postgres redis
   ```

5. **Database Setup**
   ```bash
   # Run migrations
   make migrate-up
   
   # Seed with sample data (optional)
   make seed
   ```

6. **Start Development Server**
   ```bash
   make serve-server
   ```

The server will start on `http://localhost:4000`

### Development Tools

#### Essential Tools

- **Air**: Live reload for Go applications
  ```bash
  go install github.com/air-verse/air@latest
  air
  ```

- **Swagger**: API documentation
  ```bash
  make swagger
  # Access at http://localhost:4000/swagger/index.html
  ```

- **SQLC**: Type-safe SQL code generation
  ```bash
  make sqlc
  ```

#### Optional Tools

- **Delve**: Go debugger
  ```bash
  go install github.com/go-delve/delve/cmd/dlv@latest
  ```

- **golangci-lint**: Comprehensive Go linter
  ```bash
  go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
  ```

## Project Architecture

### Directory Structure

```
server/
├── cmd/                    # Application entry points
│   ├── migrate/           # Database migration CLI
│   ├── seed/              # Database seeding CLI
│   └── web/               # Main server application
├── config/                # Configuration management
├── docs/                  # Generated Swagger documentation
├── internal/              # Private application code
│   ├── api/               # HTTP handlers and middleware
│   ├── cmd/               # Cobra CLI commands
│   ├── db/                # Database layer
│   │   ├── query/         # SQL queries
│   │   └── repository/    # Generated SQLC code
│   ├── utils/             # Internal utilities
│   └── worker/            # Background job processing
├── migrations/            # Database migration files
├── pkg/                   # Public reusable packages
│   ├── auth/              # Authentication utilities
│   ├── cachesrv/          # Cache service abstraction
│   ├── logger/            # Structured logging
│   ├── mailer/            # Email service
│   ├── pmgateway/         # Payment gateway integration
│   └── upload/            # File upload service
├── seeds/                 # Database seed data
├── static/                # Static assets
└── volumes/               # Docker volumes
```

### Architecture Patterns

#### Clean Architecture

The project follows Clean Architecture principles:

- **Entities**: Core business models in `internal/db/repository/models.go`
- **Use Cases**: Business logic in service layers
- **Interface Adapters**: HTTP handlers in `internal/api/`
- **Frameworks & Drivers**: Database, web framework, external services

#### Repository Pattern

Database access is abstracted through the repository pattern:

```go
// Repository interface
type Repository interface {
    CreateUser(ctx context.Context, arg CreateUserParams) (User, error)
    GetUser(ctx context.Context, id uuid.UUID) (User, error)
    UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error)
    DeleteUser(ctx context.Context, id uuid.UUID) error
}

// Implementation generated by SQLC
type Queries struct {
    db DBTX
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
    // Generated implementation
}
```

#### Dependency Injection

Services are injected through constructor functions:

```go
type Server struct {
    config          config.Config
    repo            repository.Repository
    tokenGenerator  auth.TokenGenerator
    uploadService   upload.UploadService
    paymentGateway  pmgateway.PaymentGateway
    cache           cachesrv.Cache
    taskDistributor worker.TaskDistributor
}

func NewServer(
    config config.Config,
    repo repository.Repository,
    tokenGenerator auth.TokenGenerator,
    // ... other dependencies
) *Server {
    return &Server{
        config:         config,
        repo:          repo,
        tokenGenerator: tokenGenerator,
        // ... other fields
    }
}
```

## Coding Standards

### Go Style Guide

We follow the [Go Style Guide](https://github.com/golang/go/wiki/CodeReviewComments) and [Effective Go](https://golang.org/doc/effective_go.html).

#### Naming Conventions

```go
// Constants: PascalCase
const (
    DefaultPageSize = 10
    MaxPageSize     = 100
)

// Variables: camelCase
var (
    httpClient *http.Client
    dbPool     *pgxpool.Pool
)

// Functions: PascalCase (exported) or camelCase (private)
func CreateUser(ctx context.Context, user User) error { }
func validateUser(user User) error { }

// Structs: PascalCase
type UserService struct {
    repo repository.UserRepository
}

// Methods: PascalCase (exported) or camelCase (private)
func (s *UserService) GetUser(id uuid.UUID) (*User, error) { }
func (s *UserService) hashPassword(password string) string { }
```

#### Error Handling

```go
// Always handle errors explicitly
user, err := repo.GetUser(ctx, userID)
if err != nil {
    if errors.Is(err, sql.ErrNoRows) {
        return nil, ErrUserNotFound
    }
    return nil, fmt.Errorf("failed to get user: %w", err)
}

// Use custom error types for domain errors
type ValidationError struct {
    Field   string
    Message string
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("validation error on field %s: %s", e.Field, e.Message)
}
```

#### Context Usage

```go
// Always accept context as the first parameter
func (s *Service) ProcessOrder(ctx context.Context, orderID uuid.UUID) error {
    // Use context for cancellation and timeouts
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
    }
    
    // Pass context to downstream calls
    order, err := s.repo.GetOrder(ctx, orderID)
    if err != nil {
        return err
    }
    
    return nil
}
```

### Database Conventions

#### SQL Style

```sql
-- Table names: snake_case, plural
CREATE TABLE user_addresses (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    -- Column names: snake_case
    user_id UUID NOT NULL,
    street_address VARCHAR(255) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index names: descriptive with table prefix
CREATE INDEX idx_user_addresses_user_id ON user_addresses(user_id);

-- Constraint names: descriptive
ALTER TABLE user_addresses 
ADD CONSTRAINT fk_user_addresses_user_id 
FOREIGN KEY (user_id) REFERENCES users(id);
```

#### SQLC Queries

```sql
-- name: CreateUser :one
INSERT INTO users (
    role_id, username, email, phone_number, 
    first_name, last_name, hashed_password
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING *;

-- name: GetUser :one
SELECT * FROM users WHERE id = $1 LIMIT 1;

-- name: UpdateUser :one
UPDATE users 
SET 
    first_name = COALESCE(sqlc.narg('first_name'), first_name),
    last_name = COALESCE(sqlc.narg('last_name'), last_name),
    email = COALESCE(sqlc.narg('email'), email),
    updated_at = NOW()
WHERE id = sqlc.arg('id')
RETURNING *;
```

### API Design

#### RESTful Conventions

```go
// Resource-based URLs
GET    /api/v1/users           // List users
POST   /api/v1/users           // Create user
GET    /api/v1/users/:id       // Get specific user
PUT    /api/v1/users/:id       // Update user
DELETE /api/v1/users/:id       // Delete user

// Nested resources
GET    /api/v1/users/:id/orders    // Get user's orders
POST   /api/v1/products/:id/images // Upload product image
```

#### Request/Response Format

```go
// Request DTOs
type CreateUserRequest struct {
    Username    string `json:"username" binding:"required,min=3,max=50"`
    Email       string `json:"email" binding:"required,email"`
    PhoneNumber string `json:"phone_number" binding:"required,min=10,max=20"`
    FirstName   string `json:"first_name" binding:"required"`
    LastName    string `json:"last_name" binding:"required"`
    Password    string `json:"password" binding:"required,min=8"`
}

// Response DTOs
type UserResponse struct {
    ID          uuid.UUID `json:"id"`
    Username    string    `json:"username"`
    Email       string    `json:"email"`
    PhoneNumber string    `json:"phone_number"`
    FirstName   string    `json:"first_name"`
    LastName    string    `json:"last_name"`
    AvatarURL   string    `json:"avatar_url,omitempty"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}

// Error responses
type ErrorResponse struct {
    Error struct {
        Code    string `json:"code"`
        Message string `json:"message"`
        Details string `json:"details,omitempty"`
    } `json:"error"`
}
```

#### Handler Structure

```go
// @Summary Create a new user
// @Description Create a new user account
// @Tags users
// @Accept json
// @Produce json
// @Param request body CreateUserRequest true "User creation data"
// @Success 201 {object} UserResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users [post]
func (sv *Server) CreateUserHandler(w http.ResponseWriter, r *http.Request) {
    var req CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, errorResponse("VALIDATION_ERROR", err.Error()))
        return
    }

    // Business logic
    user, err := sv.userService.CreateUser(c.Request.Context(), req)
    if err != nil {
        if errors.Is(err, ErrUserAlreadyExists) {
            c.JSON(http.StatusConflict, errorResponse("USER_EXISTS", "User already exists"))
            return
        }
        c.JSON(http.StatusInternalServerError, errorResponse("INTERNAL_ERROR", "Failed to create user"))
        return
    }

    c.JSON(http.StatusCreated, toUserResponse(user))
}
```

## Testing Strategy

### Unit Testing

```go
func TestCreateUser(t *testing.T) {
    // Arrange
    repo := &mockUserRepository{}
    service := NewUserService(repo)
    
    user := CreateUserRequest{
        Username:  "testuser",
        Email:     "test@example.com",
        Password:  "password123",
    }
    
    // Act
    result, err := service.CreateUser(context.Background(), user)
    
    // Assert
    assert.NoError(t, err)
    assert.Equal(t, user.Username, result.Username)
    assert.Equal(t, user.Email, result.Email)
}
```

### Integration Testing

```go
func TestCreateUserIntegration(t *testing.T) {
    // Setup test database
    db := setupTestDB(t)
    defer db.Close()
    
    repo := repository.New(db)
    service := NewUserService(repo)
    
    // Test data
    user := CreateUserRequest{
        Username: "testuser",
        Email:    "test@example.com",
        Password: "password123",
    }
    
    // Execute test
    result, err := service.CreateUser(context.Background(), user)
    
    // Verify results
    require.NoError(t, err)
    assert.NotEmpty(t, result.ID)
    
    // Verify in database
    dbUser, err := repo.GetUser(context.Background(), result.ID)
    require.NoError(t, err)
    assert.Equal(t, user.Username, dbUser.Username)
}
```

### API Testing

```go
func TestCreateUserAPI(t *testing.T) {
    server := setupTestServer(t)
    
    userData := CreateUserRequest{
        Username: "testuser",
        Email:    "test@example.com",
        Password: "password123",
    }
    
    body, _ := json.Marshal(userData)
    req := httptest.NewRequest("POST", "/api/v1/users", bytes.NewBuffer(body))
    req.Header.Set("Content-Type", "application/json")
    
    w := httptest.NewRecorder()
    server.ServeHTTP(w, req)
    
    assert.Equal(t, http.StatusCreated, w.Code)
    
    var response UserResponse
    err := json.Unmarshal(w.Body.Bytes(), &response)
    require.NoError(t, err)
    assert.Equal(t, userData.Username, response.Username)
}
```

## Database Development

### Migration Guidelines

```sql
-- migrations/000002_add_user_preferences.up.sql
ALTER TABLE users ADD COLUMN preferences JSONB DEFAULT '{}';

CREATE INDEX idx_users_preferences ON users USING GIN(preferences);

-- migrations/000002_add_user_preferences.down.sql
DROP INDEX IF EXISTS idx_users_preferences;
ALTER TABLE users DROP COLUMN IF EXISTS preferences;
```

### Query Development

```sql
-- internal/db/query/users.sql

-- name: GetUserWithPreferences :one
SELECT 
    u.*,
    COALESCE(u.preferences, '{}'::jsonb) as preferences
FROM users u
WHERE u.id = $1 AND u.locked = false;

-- name: SearchUsers :many
SELECT * FROM users
WHERE 
    ($1::text IS NULL OR username ILIKE '%' || $1 || '%')
    AND ($2::text IS NULL OR email ILIKE '%' || $2 || '%')
    AND ($3::uuid IS NULL OR role_id = $3)
ORDER BY created_at DESC
LIMIT $4 OFFSET $5;
```

## Performance Optimization

### Database Optimization

1. **Query Analysis**
   ```sql
   EXPLAIN ANALYZE SELECT * FROM products WHERE category_id = $1;
   ```

2. **Index Optimization**
   ```sql
   -- Composite indexes for common queries
   CREATE INDEX idx_products_category_status ON products(category_id, status);
   ```

3. **Connection Pooling**
   ```go
   config, err := pgxpool.ParseConfig(databaseURL)
   config.MaxConns = 30
   config.MinConns = 5
   config.MaxConnLifetime = time.Hour
   config.MaxConnIdleTime = time.Minute * 30
   ```

### Caching Strategy

```go
// Redis caching for frequently accessed data
func (s *ProductService) GetProduct(ctx context.Context, id uuid.UUID) (*Product, error) {
    // Try cache first
    cacheKey := fmt.Sprintf("product:%s", id.String())
    if cached := s.cache.Get(ctx, cacheKey); cached != nil {
        var product Product
        if err := json.Unmarshal([]byte(cached), &product); err == nil {
            return &product, nil
        }
    }
    
    // Fallback to database
    product, err := s.repo.GetProduct(ctx, id)
    if err != nil {
        return nil, err
    }
    
    // Cache for future requests
    data, _ := json.Marshal(product)
    s.cache.Set(ctx, cacheKey, string(data), time.Hour)
    
    return product, nil
}
```

## Security Best Practices

### Input Validation

```go
// Use struct tags for validation
type CreateProductRequest struct {
    Name        string    `json:"name" binding:"required,min=3,max=255"`
    Price       float64   `json:"price" binding:"required,gt=0"`
    CategoryID  uuid.UUID `json:"category_id" binding:"required"`
    Description string    `json:"description" binding:"max=5000"`
}

// Custom validators
func init() {
    validator := binding.Validator.Engine().(*validator.Validate)
    validator.RegisterValidation("password", validatePassword)
}

func validatePassword(fl validator.FieldLevel) bool {
    password := fl.Field().String()
    // Implement password complexity rules
    return len(password) >= 8 && 
           regexp.MustCompile(`[A-Z]`).MatchString(password) &&
           regexp.MustCompile(`[a-z]`).MatchString(password) &&
           regexp.MustCompile(`[0-9]`).MatchString(password)
}
```

### Authentication & Authorization

```go
// Middleware for authentication
func authenticateMiddleware(tokenMaker auth.TokenGenerator) gin.HandlerFunc {
    return gin.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.AbortWithStatusJSON(http.StatusUnauthorized, 
                errorResponse("MISSING_TOKEN", "Authorization header required"))
            return
        }

        fields := strings.Fields(authHeader)
        if len(fields) < 2 || fields[0] != "Bearer" {
            c.AbortWithStatusJSON(http.StatusUnauthorized,
                errorResponse("INVALID_TOKEN", "Invalid authorization format"))
            return
        }

        payload, err := tokenMaker.VerifyToken(fields[1])
        if err != nil {
            c.AbortWithStatusJSON(http.StatusUnauthorized,
                errorResponse("INVALID_TOKEN", err.Error()))
            return
        }

        c.Set("auth_payload", payload)
        c.Next()
    })
}

// Authorization middleware
func authorizeMiddleware(allowedRoles ...string) gin.HandlerFunc {
    return gin.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        payload := c.MustGet("auth_payload").(*auth.Payload)
        
        for _, role := range allowedRoles {
            if payload.Role == role {
                c.Next()
                return
            }
        }
        
        c.AbortWithStatusJSON(http.StatusForbidden,
            errorResponse("INSUFFICIENT_PERMISSIONS", "Access denied"))
    })
}
```

## Deployment

### Docker Configuration

```dockerfile
# Multi-stage build for production
FROM golang:1.24-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main ./cmd/web

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/

COPY --from=builder /app/main .
COPY --from=builder /app/static ./static
COPY --from=builder /app/migrations ./migrations

CMD ["./main", "api"]
```

### Environment Configuration

```yaml
# docker-compose.prod.yml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "8080:4000"
    environment:
      - ENV=production
      - DB_URL=postgresql://user:pass@db:5432/eshop
      - REDIS_URL=redis:6379
    depends_on:
      - db
      - redis
    restart: unless-stopped

  db:
    image: postgres:14
    environment:
      POSTGRES_DB: eshop
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  redis:
    image: redis:6-alpine
    restart: unless-stopped

volumes:
  postgres_data:
```

## Monitoring and Observability

### Logging

```go
// Structured logging with zerolog
func (s *Server) setupLogger() {
    zerolog.TimeFieldFormat = zerolog.TimeFormatUnix
    
    if s.config.Env == "development" {
        log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})
    }
}

// Request logging middleware
func LoggingMiddleware() gin.HandlerFunc {
    return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
        log.Info().
            Str("method", param.Method).
            Str("path", param.Path).
            Int("status", param.StatusCode).
            Dur("latency", param.Latency).
            Str("ip", param.ClientIP).
            Msg("HTTP request")
        return ""
    })
}
```

### Health Checks

```go
// Health check endpoint
func (sv *Server) HealthCheckHandler(w http.ResponseWriter, r *http.Request) {
    checks := map[string]string{
        "database": "ok",
        "redis":    "ok",
    }
    
    // Check database
    if err := sv.repo.Ping(c.Request.Context()); err != nil {
        checks["database"] = "error: " + err.Error()
    }
    
    // Check Redis
    if err := sv.cache.Ping(c.Request.Context()); err != nil {
        checks["redis"] = "error: " + err.Error()
    }
    
    status := "healthy"
    for _, check := range checks {
        if strings.HasPrefix(check, "error") {
            status = "unhealthy"
            break
        }
    }
    
    c.JSON(http.StatusOK, gin.H{
        "status": status,
        "checks": checks,
        "timestamp": time.Now(),
    })
}
```

## Contributing Guidelines

### Git Workflow

1. **Branching Strategy**
   ```bash
   # Feature branch
   git checkout -b feature/user-profile-update
   
   # Bug fix branch
   git checkout -b bugfix/order-calculation-error
   
   # Hotfix branch
   git checkout -b hotfix/security-patch
   ```

2. **Commit Messages**
   ```bash
   # Format: type(scope): description
   git commit -m "feat(auth): add JWT token refresh endpoint"
   git commit -m "fix(orders): correct tax calculation logic"
   git commit -m "docs(api): update authentication documentation"
   ```

3. **Pull Request Process**
   - Create feature branch
   - Implement changes with tests
   - Update documentation
   - Submit PR with clear description
   - Address review feedback
   - Merge after approval

### Code Review Checklist

- [ ] Code follows style guidelines
- [ ] All tests pass
- [ ] Documentation is updated
- [ ] Security best practices followed
- [ ] Performance considerations addressed
- [ ] Error handling is appropriate
- [ ] Logging is adequate

### Pre-commit Hooks

```bash
# Install pre-commit hooks
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

# .pre-commit-config.yaml
repos:
  - repo: local
    hooks:
      - id: go-fmt
        name: go fmt
        entry: gofmt
        language: system
        args: [-w, -s]
        files: \.go$
      
      - id: go-lint
        name: golangci-lint
        entry: golangci-lint
        language: system
        args: [run]
        files: \.go$
```

This development guide provides a comprehensive foundation for working with the e-commerce platform. Regular updates and team feedback will help maintain its relevance and usefulness.