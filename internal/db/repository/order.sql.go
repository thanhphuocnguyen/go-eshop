// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: order.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countOrders = `-- name: CountOrders :one
SELECT
    COUNT(*)
FROM
    orders ord
LEFT JOIN payments p ON ord.id = p.order_id
WHERE
    ord.status = COALESCE($1, ord.status) AND
    customer_id = COALESCE($2, customer_id) AND
    p.status = COALESCE($3, p.status) AND
    ord.created_at >= COALESCE($4, ord.created_at) AND
    ord.created_at <= COALESCE($5, ord.created_at)
`

type CountOrdersParams struct {
	Status        NullOrderStatus    `json:"status"`
	CustomerID    pgtype.UUID        `json:"customer_id"`
	PaymentStatus NullPaymentStatus  `json:"payment_status"`
	StartDate     pgtype.Timestamptz `json:"start_date"`
	EndDate       pgtype.Timestamptz `json:"end_date"`
}

func (q *Queries) CountOrders(ctx context.Context, arg CountOrdersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders,
		arg.Status,
		arg.CustomerID,
		arg.PaymentStatus,
		arg.StartDate,
		arg.EndDate,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

type CreateBulkOrderItemsParams struct {
	OrderID              uuid.UUID               `json:"order_id"`
	VariantID            uuid.UUID               `json:"variant_id"`
	Quantity             int16                   `json:"quantity"`
	PricePerUnitSnapshot pgtype.Numeric          `json:"price_per_unit_snapshot"`
	VariantSkuSnapshot   string                  `json:"variant_sku_snapshot"`
	ProductNameSnapshot  string                  `json:"product_name_snapshot"`
	LineTotalSnapshot    pgtype.Numeric          `json:"line_total_snapshot"`
	AttributesSnapshot   []AttributeDataSnapshot `json:"attributes_snapshot"`
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    customer_id,
    customer_email,
    customer_name,
    customer_phone,
    total_price,
    shipping_address
)
VALUES 
    ($1, $2, $3, $4,  $5, $6)
RETURNING id, customer_id, customer_email, customer_name, customer_phone, shipping_address, total_price, status, confirmed_at, delivered_at, cancelled_at, shipping_method, refunded_at, order_date, updated_at, created_at, shipping_method_id, shipping_rate_id, shipping_cost, estimated_delivery_date, tracking_number, tracking_url, shipping_provider, shipping_notes
`

type CreateOrderParams struct {
	CustomerID      uuid.UUID               `json:"customer_id"`
	CustomerEmail   string                  `json:"customer_email"`
	CustomerName    string                  `json:"customer_name"`
	CustomerPhone   string                  `json:"customer_phone"`
	TotalPrice      pgtype.Numeric          `json:"total_price"`
	ShippingAddress ShippingAddressSnapshot `json:"shipping_address"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.CustomerID,
		arg.CustomerEmail,
		arg.CustomerName,
		arg.CustomerPhone,
		arg.TotalPrice,
		arg.ShippingAddress,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.ShippingAddress,
		&i.TotalPrice,
		&i.Status,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.ShippingMethod,
		&i.RefundedAt,
		&i.OrderDate,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.ShippingMethodID,
		&i.ShippingRateID,
		&i.ShippingCost,
		&i.EstimatedDeliveryDate,
		&i.TrackingNumber,
		&i.TrackingUrl,
		&i.ShippingProvider,
		&i.ShippingNotes,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO
    order_items (order_id, variant_id, quantity, price_per_unit_snapshot, variant_sku_snapshot, product_name_snapshot, line_total_snapshot, attributes_snapshot)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, order_id, variant_id, quantity, price_per_unit_snapshot, line_total_snapshot, product_name_snapshot, variant_sku_snapshot, attributes_snapshot, created_at, updated_at, discounted_price
`

type CreateOrderItemParams struct {
	OrderID              uuid.UUID               `json:"order_id"`
	VariantID            uuid.UUID               `json:"variant_id"`
	Quantity             int16                   `json:"quantity"`
	PricePerUnitSnapshot pgtype.Numeric          `json:"price_per_unit_snapshot"`
	VariantSkuSnapshot   string                  `json:"variant_sku_snapshot"`
	ProductNameSnapshot  string                  `json:"product_name_snapshot"`
	LineTotalSnapshot    pgtype.Numeric          `json:"line_total_snapshot"`
	AttributesSnapshot   []AttributeDataSnapshot `json:"attributes_snapshot"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.VariantID,
		arg.Quantity,
		arg.PricePerUnitSnapshot,
		arg.VariantSkuSnapshot,
		arg.ProductNameSnapshot,
		arg.LineTotalSnapshot,
		arg.AttributesSnapshot,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.VariantID,
		&i.Quantity,
		&i.PricePerUnitSnapshot,
		&i.LineTotalSnapshot,
		&i.ProductNameSnapshot,
		&i.VariantSkuSnapshot,
		&i.AttributesSnapshot,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DiscountedPrice,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM
    orders
WHERE
    id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrder, id)
	return err
}

const getOrder = `-- name: GetOrder :one
SELECT
    id, customer_id, customer_email, customer_name, customer_phone, shipping_address, total_price, status, confirmed_at, delivered_at, cancelled_at, shipping_method, refunded_at, order_date, updated_at, created_at, shipping_method_id, shipping_rate_id, shipping_cost, estimated_delivery_date, tracking_number, tracking_url, shipping_provider, shipping_notes
FROM
    orders
WHERE
    id = $1
LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.ShippingAddress,
		&i.TotalPrice,
		&i.Status,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.ShippingMethod,
		&i.RefundedAt,
		&i.OrderDate,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.ShippingMethodID,
		&i.ShippingRateID,
		&i.ShippingCost,
		&i.EstimatedDeliveryDate,
		&i.TrackingNumber,
		&i.TrackingUrl,
		&i.ShippingProvider,
		&i.ShippingNotes,
	)
	return i, err
}

const getOrderItemByID = `-- name: GetOrderItemByID :one
SELECT
    oi.id as order_item_id,
    o.id as order_id,
    p.id as product_id,
    pv.id as variant_id,
    o.customer_id
FROM
    order_items oi
JOIN
    product_variants pv ON oi.variant_id = pv.id
JOIN
    products p ON pv.product_id = p.id
JOIN
    orders o ON oi.order_id = o.id
WHERE
    oi.id = $1
LIMIT 1
`

type GetOrderItemByIDRow struct {
	OrderItemID uuid.UUID `json:"order_item_id"`
	OrderID     uuid.UUID `json:"order_id"`
	ProductID   uuid.UUID `json:"product_id"`
	VariantID   uuid.UUID `json:"variant_id"`
	CustomerID  uuid.UUID `json:"customer_id"`
}

func (q *Queries) GetOrderItemByID(ctx context.Context, id uuid.UUID) (GetOrderItemByIDRow, error) {
	row := q.db.QueryRow(ctx, getOrderItemByID, id)
	var i GetOrderItemByIDRow
	err := row.Scan(
		&i.OrderItemID,
		&i.OrderID,
		&i.ProductID,
		&i.VariantID,
		&i.CustomerID,
	)
	return i, err
}

const getOrderProducts = `-- name: GetOrderProducts :many
SELECT
    oi.id, oi.order_id, oi.variant_id, oi.quantity, oi.price_per_unit_snapshot, oi.line_total_snapshot, oi.product_name_snapshot, oi.variant_sku_snapshot, oi.attributes_snapshot, oi.created_at, oi.updated_at, oi.discounted_price,
    p.name as product_name,
    i.url as image_url
FROM
    order_items oi
JOIN
    product_variants pv ON oi.variant_id = pv.id
JOIN
    products p ON pv.product_id = p.id
LEFT JOIN image_assignments AS ia ON ia.entity_id = pv.id AND ia.entity_type = 'variant'
LEFT JOIN images AS i ON i.id = ia.image_id
WHERE
    oi.order_id = $1
`

type GetOrderProductsRow struct {
	ID                   uuid.UUID               `json:"id"`
	OrderID              uuid.UUID               `json:"order_id"`
	VariantID            uuid.UUID               `json:"variant_id"`
	Quantity             int16                   `json:"quantity"`
	PricePerUnitSnapshot pgtype.Numeric          `json:"price_per_unit_snapshot"`
	LineTotalSnapshot    pgtype.Numeric          `json:"line_total_snapshot"`
	ProductNameSnapshot  string                  `json:"product_name_snapshot"`
	VariantSkuSnapshot   string                  `json:"variant_sku_snapshot"`
	AttributesSnapshot   []AttributeDataSnapshot `json:"attributes_snapshot"`
	CreatedAt            time.Time               `json:"created_at"`
	UpdatedAt            time.Time               `json:"updated_at"`
	DiscountedPrice      pgtype.Numeric          `json:"discounted_price"`
	ProductName          string                  `json:"product_name"`
	ImageUrl             *string                 `json:"image_url"`
}

func (q *Queries) GetOrderProducts(ctx context.Context, orderID uuid.UUID) ([]GetOrderProductsRow, error) {
	rows, err := q.db.Query(ctx, getOrderProducts, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderProductsRow{}
	for rows.Next() {
		var i GetOrderProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.VariantID,
			&i.Quantity,
			&i.PricePerUnitSnapshot,
			&i.LineTotalSnapshot,
			&i.ProductNameSnapshot,
			&i.VariantSkuSnapshot,
			&i.AttributesSnapshot,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DiscountedPrice,
			&i.ProductName,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrders = `-- name: GetOrders :many
SELECT
    ord.id, ord.customer_id, ord.customer_email, ord.customer_name, ord.customer_phone, ord.shipping_address, ord.total_price, ord.status, ord.confirmed_at, ord.delivered_at, ord.cancelled_at, ord.shipping_method, ord.refunded_at, ord.order_date, ord.updated_at, ord.created_at, ord.shipping_method_id, ord.shipping_rate_id, ord.shipping_cost, ord.estimated_delivery_date, ord.tracking_number, ord.tracking_url, ord.shipping_provider, ord.shipping_notes, pm.status as payment_status, COUNT(oi.id) as total_items
FROM
    orders ord
LEFT JOIN order_items oi ON ord.id = oi.id
LEFT JOIN payments pm ON ord.id = pm.order_id
WHERE
    ord.customer_id = COALESCE($3, ord.customer_id) AND
    ord.status = COALESCE($4, ord.status) AND
    ord.created_at >= COALESCE($5, ord.created_at) AND
    ord.created_at <= COALESCE($6, ord.created_at) AND
    pm.status = COALESCE($7, pm.status)
GROUP BY ord.id, pm.status
ORDER BY
    ord.created_at DESC
LIMIT $1
OFFSET $2
`

type GetOrdersParams struct {
	Limit         int64              `json:"limit"`
	Offset        int64              `json:"offset"`
	CustomerID    pgtype.UUID        `json:"customer_id"`
	Status        NullOrderStatus    `json:"status"`
	StartDate     pgtype.Timestamptz `json:"start_date"`
	EndDate       pgtype.Timestamptz `json:"end_date"`
	PaymentStatus NullPaymentStatus  `json:"payment_status"`
}

type GetOrdersRow struct {
	ID                    uuid.UUID               `json:"id"`
	CustomerID            uuid.UUID               `json:"customer_id"`
	CustomerEmail         string                  `json:"customer_email"`
	CustomerName          string                  `json:"customer_name"`
	CustomerPhone         string                  `json:"customer_phone"`
	ShippingAddress       ShippingAddressSnapshot `json:"shipping_address"`
	TotalPrice            pgtype.Numeric          `json:"total_price"`
	Status                OrderStatus             `json:"status"`
	ConfirmedAt           pgtype.Timestamptz      `json:"confirmed_at"`
	DeliveredAt           pgtype.Timestamptz      `json:"delivered_at"`
	CancelledAt           pgtype.Timestamptz      `json:"cancelled_at"`
	ShippingMethod        *string                 `json:"shipping_method"`
	RefundedAt            pgtype.Timestamptz      `json:"refunded_at"`
	OrderDate             time.Time               `json:"order_date"`
	UpdatedAt             time.Time               `json:"updated_at"`
	CreatedAt             time.Time               `json:"created_at"`
	ShippingMethodID      pgtype.UUID             `json:"shipping_method_id"`
	ShippingRateID        pgtype.UUID             `json:"shipping_rate_id"`
	ShippingCost          pgtype.Numeric          `json:"shipping_cost"`
	EstimatedDeliveryDate pgtype.Timestamptz      `json:"estimated_delivery_date"`
	TrackingNumber        *string                 `json:"tracking_number"`
	TrackingUrl           *string                 `json:"tracking_url"`
	ShippingProvider      *string                 `json:"shipping_provider"`
	ShippingNotes         *string                 `json:"shipping_notes"`
	PaymentStatus         NullPaymentStatus       `json:"payment_status"`
	TotalItems            int64                   `json:"total_items"`
}

func (q *Queries) GetOrders(ctx context.Context, arg GetOrdersParams) ([]GetOrdersRow, error) {
	rows, err := q.db.Query(ctx, getOrders,
		arg.Limit,
		arg.Offset,
		arg.CustomerID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
		arg.PaymentStatus,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrdersRow{}
	for rows.Next() {
		var i GetOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.CustomerEmail,
			&i.CustomerName,
			&i.CustomerPhone,
			&i.ShippingAddress,
			&i.TotalPrice,
			&i.Status,
			&i.ConfirmedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.ShippingMethod,
			&i.RefundedAt,
			&i.OrderDate,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.ShippingMethodID,
			&i.ShippingRateID,
			&i.ShippingCost,
			&i.EstimatedDeliveryDate,
			&i.TrackingNumber,
			&i.TrackingUrl,
			&i.ShippingProvider,
			&i.ShippingNotes,
			&i.PaymentStatus,
			&i.TotalItems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItems = `-- name: ListOrderItems :many
SELECT
    id, order_id, variant_id, quantity, price_per_unit_snapshot, line_total_snapshot, product_name_snapshot, variant_sku_snapshot, attributes_snapshot, created_at, updated_at, discounted_price
FROM
    order_items
WHERE
    order_id = $1
ORDER BY
    id
LIMIT $2
OFFSET $3
`

type ListOrderItemsParams struct {
	OrderID uuid.UUID `json:"order_id"`
	Limit   int64     `json:"limit"`
	Offset  int64     `json:"offset"`
}

func (q *Queries) ListOrderItems(ctx context.Context, arg ListOrderItemsParams) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, listOrderItems, arg.OrderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.VariantID,
			&i.Quantity,
			&i.PricePerUnitSnapshot,
			&i.LineTotalSnapshot,
			&i.ProductNameSnapshot,
			&i.VariantSkuSnapshot,
			&i.AttributesSnapshot,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DiscountedPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE
    orders
SET
    status = coalesce($1, status),
    confirmed_at = coalesce($2, confirmed_at),
    cancelled_at = coalesce($3, cancelled_at),
    delivered_at = coalesce($4, delivered_at),
    updated_at = now()
WHERE
    id = $5
RETURNING id, customer_id, customer_email, customer_name, customer_phone, shipping_address, total_price, status, confirmed_at, delivered_at, cancelled_at, shipping_method, refunded_at, order_date, updated_at, created_at, shipping_method_id, shipping_rate_id, shipping_cost, estimated_delivery_date, tracking_number, tracking_url, shipping_provider, shipping_notes
`

type UpdateOrderParams struct {
	Status      NullOrderStatus    `json:"status"`
	ConfirmedAt pgtype.Timestamptz `json:"confirmed_at"`
	CancelledAt pgtype.Timestamptz `json:"cancelled_at"`
	DeliveredAt pgtype.Timestamptz `json:"delivered_at"`
	ID          uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder,
		arg.Status,
		arg.ConfirmedAt,
		arg.CancelledAt,
		arg.DeliveredAt,
		arg.ID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.ShippingAddress,
		&i.TotalPrice,
		&i.Status,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.ShippingMethod,
		&i.RefundedAt,
		&i.OrderDate,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.ShippingMethodID,
		&i.ShippingRateID,
		&i.ShippingCost,
		&i.EstimatedDeliveryDate,
		&i.TrackingNumber,
		&i.TrackingUrl,
		&i.ShippingProvider,
		&i.ShippingNotes,
	)
	return i, err
}
