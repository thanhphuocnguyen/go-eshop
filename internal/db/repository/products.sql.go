// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type AddBulkProductsParams struct {
	BrandID     pgtype.UUID `json:"brandId"`
	Name        string      `json:"name"`
	Description string      `json:"description"`
}

const archiveProduct = `-- name: ArchiveProduct :exec
UPDATE products SET is_active = $1, updated_at = NOW() WHERE id = $2
`

type ArchiveProductParams struct {
	IsActive *bool     `json:"isActive"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) ArchiveProduct(ctx context.Context, arg ArchiveProductParams) error {
	_, err := q.db.Exec(ctx, archiveProduct, arg.IsActive, arg.ID)
	return err
}

const archiveProductVariant = `-- name: ArchiveProductVariant :exec
UPDATE product_variants SET is_active = $1, updated_at = NOW() WHERE id = $2
`

type ArchiveProductVariantParams struct {
	IsActive *bool     `json:"isActive"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) ArchiveProductVariant(ctx context.Context, arg ArchiveProductVariantParams) error {
	_, err := q.db.Exec(ctx, archiveProductVariant, arg.IsActive, arg.ID)
	return err
}

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM products
WHERE
    is_active = COALESCE($1, is_active) AND name ILIKE COALESCE($2, '%')
    AND brand_id = COALESCE($3, brand_id)
`

type CountProductsParams struct {
	IsActive *bool       `json:"isActive"`
	Name     *string     `json:"name"`
	BrandID  pgtype.UUID `json:"brandId"`
}

func (q *Queries) CountProducts(ctx context.Context, arg CountProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts, arg.IsActive, arg.Name, arg.BrandID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

type CreateBulkProductVariantsParams struct {
	ProductID uuid.UUID      `json:"productId"`
	Sku       string         `json:"sku"`
	Price     pgtype.Numeric `json:"price"`
	Stock     int32          `json:"stock"`
	Weight    pgtype.Numeric `json:"weight"`
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (name, description, short_description, base_price, base_sku, slug, brand_id) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, name, description, short_description, base_price, base_sku, slug, is_active, image_url, image_id, discount_percentage, purchased_count, avg_rating, rating_count, one_star_count, two_star_count, three_star_count, four_star_count, five_star_count, created_at, updated_at, brand_id
`

type CreateProductParams struct {
	Name             string         `json:"name"`
	Description      string         `json:"description"`
	ShortDescription *string        `json:"shortDescription"`
	BasePrice        pgtype.Numeric `json:"basePrice"`
	BaseSku          string         `json:"baseSku"`
	Slug             string         `json:"slug"`
	BrandID          pgtype.UUID    `json:"brandId"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Name,
		arg.Description,
		arg.ShortDescription,
		arg.BasePrice,
		arg.BaseSku,
		arg.Slug,
		arg.BrandID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ShortDescription,
		&i.BasePrice,
		&i.BaseSku,
		&i.Slug,
		&i.IsActive,
		&i.ImageUrl,
		&i.ImageID,
		&i.DiscountPercentage,
		&i.PurchasedCount,
		&i.AvgRating,
		&i.RatingCount,
		&i.OneStarCount,
		&i.TwoStarCount,
		&i.ThreeStarCount,
		&i.FourStarCount,
		&i.FiveStarCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BrandID,
	)
	return i, err
}

const createProductVariant = `-- name: CreateProductVariant :one
INSERT INTO product_variants (product_id, description, sku, price, stock, weight) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, product_id, description, sku, price, stock, weight, is_active, created_at, updated_at, image_url, image_id
`

type CreateProductVariantParams struct {
	ProductID   uuid.UUID      `json:"productId"`
	Description *string        `json:"description"`
	Sku         string         `json:"sku"`
	Price       pgtype.Numeric `json:"price"`
	Stock       int32          `json:"stock"`
	Weight      pgtype.Numeric `json:"weight"`
}

// Product Variants --
func (q *Queries) CreateProductVariant(ctx context.Context, arg CreateProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, createProductVariant,
		arg.ProductID,
		arg.Description,
		arg.Sku,
		arg.Price,
		arg.Stock,
		arg.Weight,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Description,
		&i.Sku,
		&i.Price,
		&i.Stock,
		&i.Weight,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImageUrl,
		&i.ImageID,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const deleteProductVariant = `-- name: DeleteProductVariant :exec
DELETE FROM product_variants WHERE id = $1 AND product_id = $2
`

type DeleteProductVariantParams struct {
	ID        uuid.UUID `json:"id"`
	ProductID uuid.UUID `json:"productId"`
}

func (q *Queries) DeleteProductVariant(ctx context.Context, arg DeleteProductVariantParams) error {
	_, err := q.db.Exec(ctx, deleteProductVariant, arg.ID, arg.ProductID)
	return err
}

const getAdminProductList = `-- name: GetAdminProductList :many
SELECT p.id, p.name, p.description, p.short_description, p.base_price, p.base_sku, p.slug, p.is_active, p.image_url, p.image_id, p.discount_percentage, p.purchased_count, p.avg_rating, p.rating_count, p.one_star_count, p.two_star_count, p.three_star_count, p.four_star_count, p.five_star_count, p.created_at, p.updated_at, p.brand_id FROM products as p
WHERE
    p.is_active = COALESCE($3, p.is_active) 
    AND p.name ILIKE COALESCE($4, p.name)
    AND p.slug ILIKE COALESCE($5, p.slug)
GROUP BY p.id ORDER BY $6::text LIMIT $1 OFFSET $2
`

type GetAdminProductListParams struct {
	Limit    int64   `json:"limit"`
	Offset   int64   `json:"offset"`
	IsActive *bool   `json:"isActive"`
	Search   *string `json:"search"`
	Slug     *string `json:"slug"`
	Orderby  string  `json:"orderby"`
}

func (q *Queries) GetAdminProductList(ctx context.Context, arg GetAdminProductListParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getAdminProductList,
		arg.Limit,
		arg.Offset,
		arg.IsActive,
		arg.Search,
		arg.Slug,
		arg.Orderby,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ShortDescription,
			&i.BasePrice,
			&i.BaseSku,
			&i.Slug,
			&i.IsActive,
			&i.ImageUrl,
			&i.ImageID,
			&i.DiscountPercentage,
			&i.PurchasedCount,
			&i.AvgRating,
			&i.RatingCount,
			&i.OneStarCount,
			&i.TwoStarCount,
			&i.ThreeStarCount,
			&i.FourStarCount,
			&i.FiveStarCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BrandID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT products.id, products.name, products.description, products.short_description, products.base_price, products.base_sku, products.slug, products.is_active, products.image_url, products.image_id, products.discount_percentage, products.purchased_count, products.avg_rating, products.rating_count, products.one_star_count, products.two_star_count, products.three_star_count, products.four_star_count, products.five_star_count, products.created_at, products.updated_at, products.brand_id FROM products WHERE products.id = $1 AND is_active = COALESCE($2, TRUE) GROUP BY products.id
`

type GetProductByIDParams struct {
	ID       uuid.UUID `json:"id"`
	IsActive *bool     `json:"isActive"`
}

func (q *Queries) GetProductByID(ctx context.Context, arg GetProductByIDParams) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByID, arg.ID, arg.IsActive)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ShortDescription,
		&i.BasePrice,
		&i.BaseSku,
		&i.Slug,
		&i.IsActive,
		&i.ImageUrl,
		&i.ImageID,
		&i.DiscountPercentage,
		&i.PurchasedCount,
		&i.AvgRating,
		&i.RatingCount,
		&i.OneStarCount,
		&i.TwoStarCount,
		&i.ThreeStarCount,
		&i.FourStarCount,
		&i.FiveStarCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BrandID,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT products.id, products.name, products.description, products.short_description, products.base_price, products.base_sku, products.slug, products.is_active, products.image_url, products.image_id, products.discount_percentage, products.purchased_count, products.avg_rating, products.rating_count, products.one_star_count, products.two_star_count, products.three_star_count, products.four_star_count, products.five_star_count, products.created_at, products.updated_at, products.brand_id FROM products WHERE products.slug = $1 AND is_active = COALESCE($2, TRUE)
`

type GetProductBySlugParams struct {
	Slug     string `json:"slug"`
	IsActive *bool  `json:"isActive"`
}

func (q *Queries) GetProductBySlug(ctx context.Context, arg GetProductBySlugParams) (Product, error) {
	row := q.db.QueryRow(ctx, getProductBySlug, arg.Slug, arg.IsActive)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ShortDescription,
		&i.BasePrice,
		&i.BaseSku,
		&i.Slug,
		&i.IsActive,
		&i.ImageUrl,
		&i.ImageID,
		&i.DiscountPercentage,
		&i.PurchasedCount,
		&i.AvgRating,
		&i.RatingCount,
		&i.OneStarCount,
		&i.TwoStarCount,
		&i.ThreeStarCount,
		&i.FourStarCount,
		&i.FiveStarCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BrandID,
	)
	return i, err
}

const getProductDetail = `-- name: GetProductDetail :one
SELECT p.id, p.name, p.description, p.short_description, p.base_price, p.base_sku, p.slug, p.is_active, p.image_url, p.image_id, p.discount_percentage, p.purchased_count, p.avg_rating, p.rating_count, p.one_star_count, p.two_star_count, p.three_star_count, p.four_star_count, p.five_star_count, p.created_at, p.updated_at, p.brand_id,
    JSON_BUILD_OBJECT('id', b.id, 'name', b.name) AS brand,
    JSONB_AGG(DISTINCT JSONB_BUILD_OBJECT('id', c.id, 'name', c.name)) FILTER (WHERE c.id IS NOT NULL) AS categories,
    JSONB_AGG(DISTINCT JSONB_BUILD_OBJECT('id', cl.id, 'name', cl.name)) FILTER (WHERE cl.id IS NOT NULL) AS collections,
    JSONB_AGG(DISTINCT JSONB_BUILD_OBJECT('attributeId', a.id,'attributeName', a.name)) FILTER (WHERE a.id IS NOT NULL) AS attributes,
    JSONB_AGG(DISTINCT JSONB_BUILD_OBJECT(
        'id', pv.id,
        'sku', pv.sku,
        'price', pv.price,
        'stock', pv.stock,
        'isActive', pv.is_active,
        'imageUrl', pv.image_url,
        'imageId', pv.image_id
    )) FILTER (WHERE pv.id IS NOT NULL) AS variants
FROM products p
LEFT JOIN brands AS b ON p.brand_id = b.id
LEFT JOIN category_products AS cp ON p.id = cp.product_id
LEFT JOIN collection_products AS colp ON p.id = colp.product_id
LEFT JOIN categories as c ON cp.category_id = c.id
LEFT JOIN collections as cl ON colp.collection_id = cl.id
LEFT JOIN product_attributes pa ON p.id = pa.product_id
LEFT JOIN attributes a ON pa.attribute_id = a.id
LEFT JOIN product_variants pv ON pv.product_id = p.id
WHERE (p.id = $1 OR p.slug = $2) AND p.is_active = COALESCE($3, TRUE)
GROUP BY p.id, b.id LIMIT 1
`

type GetProductDetailParams struct {
	ID       uuid.UUID `json:"id"`
	Slug     string    `json:"slug"`
	IsActive *bool     `json:"isActive"`
}

type GetProductDetailRow struct {
	ID                 uuid.UUID      `json:"id"`
	Name               string         `json:"name"`
	Description        string         `json:"description"`
	ShortDescription   *string        `json:"shortDescription"`
	BasePrice          pgtype.Numeric `json:"basePrice"`
	BaseSku            string         `json:"baseSku"`
	Slug               string         `json:"slug"`
	IsActive           *bool          `json:"isActive"`
	ImageUrl           *string        `json:"imageUrl"`
	ImageID            *string        `json:"imageId"`
	DiscountPercentage pgtype.Numeric `json:"discountPercentage"`
	PurchasedCount     *int32         `json:"purchasedCount"`
	AvgRating          pgtype.Numeric `json:"avgRating"`
	RatingCount        int32          `json:"ratingCount"`
	OneStarCount       int32          `json:"oneStarCount"`
	TwoStarCount       int32          `json:"twoStarCount"`
	ThreeStarCount     int32          `json:"threeStarCount"`
	FourStarCount      int32          `json:"fourStarCount"`
	FiveStarCount      int32          `json:"fiveStarCount"`
	CreatedAt          time.Time      `json:"createdAt"`
	UpdatedAt          time.Time      `json:"updatedAt"`
	BrandID            pgtype.UUID    `json:"brandId"`
	Brand              []byte         `json:"brand"`
	Categories         []byte         `json:"categories"`
	Collections        []byte         `json:"collections"`
	Attributes         []byte         `json:"attributes"`
	Variants           []byte         `json:"variants"`
}

func (q *Queries) GetProductDetail(ctx context.Context, arg GetProductDetailParams) (GetProductDetailRow, error) {
	row := q.db.QueryRow(ctx, getProductDetail, arg.ID, arg.Slug, arg.IsActive)
	var i GetProductDetailRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ShortDescription,
		&i.BasePrice,
		&i.BaseSku,
		&i.Slug,
		&i.IsActive,
		&i.ImageUrl,
		&i.ImageID,
		&i.DiscountPercentage,
		&i.PurchasedCount,
		&i.AvgRating,
		&i.RatingCount,
		&i.OneStarCount,
		&i.TwoStarCount,
		&i.ThreeStarCount,
		&i.FourStarCount,
		&i.FiveStarCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BrandID,
		&i.Brand,
		&i.Categories,
		&i.Collections,
		&i.Attributes,
		&i.Variants,
	)
	return i, err
}

const getProductList = `-- name: GetProductList :many
SELECT p.id, p.name, p.description, p.short_description, p.base_price, p.base_sku, p.slug, p.is_active, p.image_url, p.image_id, p.discount_percentage, p.purchased_count, p.avg_rating, p.rating_count, p.one_star_count, p.two_star_count, p.three_star_count, p.four_star_count, p.five_star_count, p.created_at, p.updated_at, p.brand_id, MIN(pv.price) as min_price, COUNT(pv.id) as variant_count FROM products as p
LEFT JOIN collection_products cp ON p.id = cp.product_id
LEFT JOIN collections c ON cp.collection_id = c.id
LEFT JOIN category_products catp ON p.id = catp.product_id
LEFT JOIN categories cat ON catp.category_id = cat.id
LEFT JOIN brands b ON p.brand_id = b.id
LEFT JOIN product_variants pv ON pv.product_id = p.id
WHERE
    p.is_active = COALESCE($3, p.is_active) 
    AND p.name ILIKE COALESCE($4, '%')
    AND ($5::uuid[] is null or p.brand_id = ANY($5::uuid[]))
    AND ($6::uuid[] is null or c.id = ANY($6::uuid[]))
    AND ($7::uuid[] is null or cat.id = ANY($7::uuid[]))
    AND pv.stock > 0
GROUP BY p.id
ORDER BY $8::text LIMIT $1 OFFSET $2
`

type GetProductListParams struct {
	Limit         int64       `json:"limit"`
	Offset        int64       `json:"offset"`
	IsActive      *bool       `json:"isActive"`
	Search        *string     `json:"search"`
	BrandIds      []uuid.UUID `json:"brandIds"`
	CollectionIds []uuid.UUID `json:"collectionIds"`
	CategoryIds   []uuid.UUID `json:"categoryIds"`
	Orderby       string      `json:"orderby"`
}

type GetProductListRow struct {
	ID                 uuid.UUID      `json:"id"`
	Name               string         `json:"name"`
	Description        string         `json:"description"`
	ShortDescription   *string        `json:"shortDescription"`
	BasePrice          pgtype.Numeric `json:"basePrice"`
	BaseSku            string         `json:"baseSku"`
	Slug               string         `json:"slug"`
	IsActive           *bool          `json:"isActive"`
	ImageUrl           *string        `json:"imageUrl"`
	ImageID            *string        `json:"imageId"`
	DiscountPercentage pgtype.Numeric `json:"discountPercentage"`
	PurchasedCount     *int32         `json:"purchasedCount"`
	AvgRating          pgtype.Numeric `json:"avgRating"`
	RatingCount        int32          `json:"ratingCount"`
	OneStarCount       int32          `json:"oneStarCount"`
	TwoStarCount       int32          `json:"twoStarCount"`
	ThreeStarCount     int32          `json:"threeStarCount"`
	FourStarCount      int32          `json:"fourStarCount"`
	FiveStarCount      int32          `json:"fiveStarCount"`
	CreatedAt          time.Time      `json:"createdAt"`
	UpdatedAt          time.Time      `json:"updatedAt"`
	BrandID            pgtype.UUID    `json:"brandId"`
	MinPrice           pgtype.Numeric `json:"minPrice"`
	VariantCount       int64          `json:"variantCount"`
}

func (q *Queries) GetProductList(ctx context.Context, arg GetProductListParams) ([]GetProductListRow, error) {
	rows, err := q.db.Query(ctx, getProductList,
		arg.Limit,
		arg.Offset,
		arg.IsActive,
		arg.Search,
		arg.BrandIds,
		arg.CollectionIds,
		arg.CategoryIds,
		arg.Orderby,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductListRow{}
	for rows.Next() {
		var i GetProductListRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ShortDescription,
			&i.BasePrice,
			&i.BaseSku,
			&i.Slug,
			&i.IsActive,
			&i.ImageUrl,
			&i.ImageID,
			&i.DiscountPercentage,
			&i.PurchasedCount,
			&i.AvgRating,
			&i.RatingCount,
			&i.OneStarCount,
			&i.TwoStarCount,
			&i.ThreeStarCount,
			&i.FourStarCount,
			&i.FiveStarCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BrandID,
			&i.MinPrice,
			&i.VariantCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductVariantByID = `-- name: GetProductVariantByID :one
SELECT id, product_id, description, sku, price, stock, weight, is_active, created_at, updated_at, image_url, image_id FROM product_variants WHERE id = $1 AND product_id = $2 AND is_active = COALESCE($3, TRUE) LIMIT 1
`

type GetProductVariantByIDParams struct {
	ID        uuid.UUID `json:"id"`
	ProductID uuid.UUID `json:"productId"`
	IsActive  *bool     `json:"isActive"`
}

func (q *Queries) GetProductVariantByID(ctx context.Context, arg GetProductVariantByIDParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, getProductVariantByID, arg.ID, arg.ProductID, arg.IsActive)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Description,
		&i.Sku,
		&i.Price,
		&i.Stock,
		&i.Weight,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImageUrl,
		&i.ImageID,
	)
	return i, err
}

const getProductVariantList = `-- name: GetProductVariantList :many
SELECT v.id, v.product_id, v.description, v.sku, v.price, v.stock, v.weight, v.is_active, v.created_at, v.updated_at, v.image_url, v.image_id, 
    JSONB_AGG(
        DISTINCT JSONB_BUILD_OBJECT('id', av.id, 'value', av.value, 'attribute_id', av.attribute_id)
    ) FILTER (WHERE av.id IS NOT NULL) AS attribute_values
FROM product_variants v
LEFT JOIN variant_attribute_values pva ON v.id = pva.variant_id
LEFT JOIN attribute_values av ON pva.attribute_value_id = av.id
WHERE v.product_id = $1 AND v.is_active = COALESCE($2, v.is_active)
GROUP BY v.id
ORDER BY v.id, v.created_at DESC
`

type GetProductVariantListParams struct {
	ProductID uuid.UUID `json:"productId"`
	IsActive  *bool     `json:"isActive"`
}

type GetProductVariantListRow struct {
	ID              uuid.UUID      `json:"id"`
	ProductID       uuid.UUID      `json:"productId"`
	Description     *string        `json:"description"`
	Sku             string         `json:"sku"`
	Price           pgtype.Numeric `json:"price"`
	Stock           int32          `json:"stock"`
	Weight          pgtype.Numeric `json:"weight"`
	IsActive        *bool          `json:"isActive"`
	CreatedAt       time.Time      `json:"createdAt"`
	UpdatedAt       time.Time      `json:"updatedAt"`
	ImageUrl        *string        `json:"imageUrl"`
	ImageID         *string        `json:"imageId"`
	AttributeValues []byte         `json:"attributeValues"`
}

func (q *Queries) GetProductVariantList(ctx context.Context, arg GetProductVariantListParams) ([]GetProductVariantListRow, error) {
	rows, err := q.db.Query(ctx, getProductVariantList, arg.ProductID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductVariantListRow{}
	for rows.Next() {
		var i GetProductVariantListRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Description,
			&i.Sku,
			&i.Price,
			&i.Stock,
			&i.Weight,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ImageUrl,
			&i.ImageID,
			&i.AttributeValues,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantDetailByID = `-- name: GetVariantDetailByID :many
SELECT product_variants.id, product_variants.product_id, product_variants.description, product_variants.sku, product_variants.price, product_variants.stock, product_variants.weight, product_variants.is_active, product_variants.created_at, product_variants.updated_at, product_variants.image_url, product_variants.image_id, attribute_values.id as attribute_value_id, attribute_values.value as attribute_value FROM product_variants
LEFT JOIN variant_attribute_values ON product_variants.id = variant_attribute_values.variant_id
LEFT JOIN attribute_values ON variant_attribute_values.attribute_value_id = attribute_values.id
WHERE product_variants.id = $1 AND product_variants.product_id = $2 AND product_variants.is_active = COALESCE($3, product_variants.is_active)
GROUP BY product_variants.id, attribute_values.id
`

type GetVariantDetailByIDParams struct {
	ID        uuid.UUID `json:"id"`
	ProductID uuid.UUID `json:"productId"`
	IsActive  *bool     `json:"isActive"`
}

type GetVariantDetailByIDRow struct {
	ID               uuid.UUID      `json:"id"`
	ProductID        uuid.UUID      `json:"productId"`
	Description      *string        `json:"description"`
	Sku              string         `json:"sku"`
	Price            pgtype.Numeric `json:"price"`
	Stock            int32          `json:"stock"`
	Weight           pgtype.Numeric `json:"weight"`
	IsActive         *bool          `json:"isActive"`
	CreatedAt        time.Time      `json:"createdAt"`
	UpdatedAt        time.Time      `json:"updatedAt"`
	ImageUrl         *string        `json:"imageUrl"`
	ImageID          *string        `json:"imageId"`
	AttributeValueID *int64         `json:"attributeValueId"`
	AttributeValue   *string        `json:"attributeValue"`
}

func (q *Queries) GetVariantDetailByID(ctx context.Context, arg GetVariantDetailByIDParams) ([]GetVariantDetailByIDRow, error) {
	rows, err := q.db.Query(ctx, getVariantDetailByID, arg.ID, arg.ProductID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVariantDetailByIDRow{}
	for rows.Next() {
		var i GetVariantDetailByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Description,
			&i.Sku,
			&i.Price,
			&i.Stock,
			&i.Weight,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ImageUrl,
			&i.ImageID,
			&i.AttributeValueID,
			&i.AttributeValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE
    products
SET
    name = coalesce($1, name),
    description = coalesce($2, description),
    short_description = coalesce($3, short_description),
    brand_id = coalesce($4, brand_id),
    slug = coalesce($5, slug),
    base_price = coalesce($6, base_price),
    base_sku = coalesce($7, base_sku),
    is_active = coalesce($8, is_active),
    image_url = coalesce($9, image_url),
    image_id = coalesce($10, image_id),
    updated_at = NOW()
WHERE id = $11 RETURNING id, name, description, short_description, base_price, base_sku, slug, is_active, image_url, image_id, discount_percentage, purchased_count, avg_rating, rating_count, one_star_count, two_star_count, three_star_count, four_star_count, five_star_count, created_at, updated_at, brand_id
`

type UpdateProductParams struct {
	Name             *string        `json:"name"`
	Description      *string        `json:"description"`
	ShortDescription *string        `json:"shortDescription"`
	BrandID          pgtype.UUID    `json:"brandId"`
	Slug             *string        `json:"slug"`
	BasePrice        pgtype.Numeric `json:"basePrice"`
	BaseSku          *string        `json:"baseSku"`
	IsActive         *bool          `json:"isActive"`
	ImageUrl         *string        `json:"imageUrl"`
	ImageID          *string        `json:"imageId"`
	ID               uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.Name,
		arg.Description,
		arg.ShortDescription,
		arg.BrandID,
		arg.Slug,
		arg.BasePrice,
		arg.BaseSku,
		arg.IsActive,
		arg.ImageUrl,
		arg.ImageID,
		arg.ID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ShortDescription,
		&i.BasePrice,
		&i.BaseSku,
		&i.Slug,
		&i.IsActive,
		&i.ImageUrl,
		&i.ImageID,
		&i.DiscountPercentage,
		&i.PurchasedCount,
		&i.AvgRating,
		&i.RatingCount,
		&i.OneStarCount,
		&i.TwoStarCount,
		&i.ThreeStarCount,
		&i.FourStarCount,
		&i.FiveStarCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BrandID,
	)
	return i, err
}

const updateProductStock = `-- name: UpdateProductStock :one
UPDATE product_variants SET stock = stock - $1 WHERE id = $2 RETURNING id, product_id, description, sku, price, stock, weight, is_active, created_at, updated_at, image_url, image_id
`

type UpdateProductStockParams struct {
	Stock int32     `json:"stock"`
	ID    uuid.UUID `json:"id"`
}

func (q *Queries) UpdateProductStock(ctx context.Context, arg UpdateProductStockParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, updateProductStock, arg.Stock, arg.ID)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Description,
		&i.Sku,
		&i.Price,
		&i.Stock,
		&i.Weight,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImageUrl,
		&i.ImageID,
	)
	return i, err
}

const updateProductVariant = `-- name: UpdateProductVariant :one
UPDATE product_variants
SET
    sku = coalesce($1, sku),
    price = coalesce($2, price),
    stock = coalesce($3, stock),
    description = coalesce($4, description),
    weight = coalesce($5, weight),
    is_active = coalesce($6, is_active),
    image_url = coalesce($7, image_url),
    image_id = coalesce($8, image_id),
    updated_at = NOW()
WHERE id = $9 AND product_id = $10 RETURNING id, product_id, description, sku, price, stock, weight, is_active, created_at, updated_at, image_url, image_id
`

type UpdateProductVariantParams struct {
	Sku         *string        `json:"sku"`
	Price       pgtype.Numeric `json:"price"`
	Stock       *int32         `json:"stock"`
	Description *string        `json:"description"`
	Weight      pgtype.Numeric `json:"weight"`
	IsActive    *bool          `json:"isActive"`
	ImageUrl    *string        `json:"imageUrl"`
	ImageID     *string        `json:"imageId"`
	ID          uuid.UUID      `json:"id"`
	ProductID   uuid.UUID      `json:"productId"`
}

func (q *Queries) UpdateProductVariant(ctx context.Context, arg UpdateProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, updateProductVariant,
		arg.Sku,
		arg.Price,
		arg.Stock,
		arg.Description,
		arg.Weight,
		arg.IsActive,
		arg.ImageUrl,
		arg.ImageID,
		arg.ID,
		arg.ProductID,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Description,
		&i.Sku,
		&i.Price,
		&i.Stock,
		&i.Weight,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImageUrl,
		&i.ImageID,
	)
	return i, err
}
