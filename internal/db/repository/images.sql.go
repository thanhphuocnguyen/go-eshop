// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: images.sql

package repository

import (
	"context"

	"github.com/google/uuid"
)

const deleteProductImage = `-- name: DeleteProductImage :exec
DELETE FROM product_images WHERE id = $1
`

func (q *Queries) DeleteProductImage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductImage, id)
	return err
}

const deleteProductImagesByProductID = `-- name: DeleteProductImagesByProductID :exec
DELETE FROM product_images WHERE product_id = $1
`

func (q *Queries) DeleteProductImagesByProductID(ctx context.Context, productID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductImagesByProductID, productID)
	return err
}

const getImageByID = `-- name: GetImageByID :one
SELECT id, product_id, image_url, image_id, alt_text, caption, mime_type, file_size, width, height, display_order, is_primary, uploaded_at, updated_at FROM product_images WHERE id = $1 LIMIT 1
`

func (q *Queries) GetImageByID(ctx context.Context, id uuid.UUID) (ProductImage, error) {
	row := q.db.QueryRow(ctx, getImageByID, id)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ImageUrl,
		&i.ImageID,
		&i.AltText,
		&i.Caption,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.DisplayOrder,
		&i.IsPrimary,
		&i.UploadedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getImageByImageID = `-- name: GetImageByImageID :one
SELECT id, product_id, image_url, image_id, alt_text, caption, mime_type, file_size, width, height, display_order, is_primary, uploaded_at, updated_at FROM product_images WHERE image_id = $1 LIMIT 1
`

func (q *Queries) GetImageByImageID(ctx context.Context, imageID string) (ProductImage, error) {
	row := q.db.QueryRow(ctx, getImageByImageID, imageID)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ImageUrl,
		&i.ImageID,
		&i.AltText,
		&i.Caption,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.DisplayOrder,
		&i.IsPrimary,
		&i.UploadedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getImagesByProductID = `-- name: GetImagesByProductID :many
SELECT id, product_id, image_url, image_id, alt_text, caption, mime_type, file_size, width, height, display_order, is_primary, uploaded_at, updated_at FROM product_images WHERE product_id = $1 ORDER BY display_order
`

func (q *Queries) GetImagesByProductID(ctx context.Context, productID uuid.UUID) ([]ProductImage, error) {
	rows, err := q.db.Query(ctx, getImagesByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductImage{}
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ImageUrl,
			&i.ImageID,
			&i.AltText,
			&i.Caption,
			&i.MimeType,
			&i.FileSize,
			&i.Width,
			&i.Height,
			&i.DisplayOrder,
			&i.IsPrimary,
			&i.UploadedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrimaryImageByProductID = `-- name: GetPrimaryImageByProductID :one
SELECT id, product_id, image_url, image_id, alt_text, caption, mime_type, file_size, width, height, display_order, is_primary, uploaded_at, updated_at FROM product_images WHERE product_id = $1 AND is_primary = true LIMIT 1
`

func (q *Queries) GetPrimaryImageByProductID(ctx context.Context, productID uuid.UUID) (ProductImage, error) {
	row := q.db.QueryRow(ctx, getPrimaryImageByProductID, productID)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ImageUrl,
		&i.ImageID,
		&i.AltText,
		&i.Caption,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.DisplayOrder,
		&i.IsPrimary,
		&i.UploadedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductImages = `-- name: GetProductImages :many
SELECT 
    pi.id,
    pi.image_id,
    pi.image_url,
    pi.alt_text,
    pi.caption,
    pi.mime_type,
    pi.file_size,
    pi.width,
    pi.height,
    pi.product_id,
    pi.display_order,
    pi.is_primary
FROM product_images pi WHERE product_id = ANY($1::UUID[])  ORDER BY product_id, display_order
`

type GetProductImagesRow struct {
	ID           uuid.UUID `json:"id"`
	ImageID      string    `json:"imageId"`
	ImageUrl     string    `json:"imageUrl"`
	AltText      *string   `json:"altText"`
	Caption      *string   `json:"caption"`
	MimeType     *string   `json:"mimeType"`
	FileSize     *int64    `json:"fileSize"`
	Width        *int32    `json:"width"`
	Height       *int32    `json:"height"`
	ProductID    uuid.UUID `json:"productId"`
	DisplayOrder int16     `json:"displayOrder"`
	IsPrimary    bool      `json:"isPrimary"`
}

func (q *Queries) GetProductImages(ctx context.Context, productIds []uuid.UUID) ([]GetProductImagesRow, error) {
	rows, err := q.db.Query(ctx, getProductImages, productIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductImagesRow{}
	for rows.Next() {
		var i GetProductImagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ImageID,
			&i.ImageUrl,
			&i.AltText,
			&i.Caption,
			&i.MimeType,
			&i.FileSize,
			&i.Width,
			&i.Height,
			&i.ProductID,
			&i.DisplayOrder,
			&i.IsPrimary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type InsertBulkProductImagesParams struct {
	ProductID    uuid.UUID `json:"productId"`
	ImageUrl     string    `json:"imageUrl"`
	ImageID      string    `json:"imageId"`
	AltText      *string   `json:"altText"`
	Caption      *string   `json:"caption"`
	MimeType     *string   `json:"mimeType"`
	FileSize     *int64    `json:"fileSize"`
	Width        *int32    `json:"width"`
	Height       *int32    `json:"height"`
	DisplayOrder int16     `json:"displayOrder"`
	IsPrimary    bool      `json:"isPrimary"`
}

const insertProductImage = `-- name: InsertProductImage :one
INSERT INTO product_images (product_id, image_url, image_id, alt_text, caption, mime_type, file_size, width, height, display_order, is_primary) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING id, product_id, image_url, image_id, alt_text, caption, mime_type, file_size, width, height, display_order, is_primary, uploaded_at, updated_at
`

type InsertProductImageParams struct {
	ProductID    uuid.UUID `json:"productId"`
	ImageUrl     string    `json:"imageUrl"`
	ImageID      string    `json:"imageId"`
	AltText      *string   `json:"altText"`
	Caption      *string   `json:"caption"`
	MimeType     *string   `json:"mimeType"`
	FileSize     *int64    `json:"fileSize"`
	Width        *int32    `json:"width"`
	Height       *int32    `json:"height"`
	DisplayOrder int16     `json:"displayOrder"`
	IsPrimary    bool      `json:"isPrimary"`
}

func (q *Queries) InsertProductImage(ctx context.Context, arg InsertProductImageParams) (ProductImage, error) {
	row := q.db.QueryRow(ctx, insertProductImage,
		arg.ProductID,
		arg.ImageUrl,
		arg.ImageID,
		arg.AltText,
		arg.Caption,
		arg.MimeType,
		arg.FileSize,
		arg.Width,
		arg.Height,
		arg.DisplayOrder,
		arg.IsPrimary,
	)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ImageUrl,
		&i.ImageID,
		&i.AltText,
		&i.Caption,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.DisplayOrder,
		&i.IsPrimary,
		&i.UploadedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setPrimaryImage = `-- name: SetPrimaryImage :exec
UPDATE product_images SET is_primary = CASE WHEN id = $2 THEN true ELSE false END, updated_at = NOW() WHERE product_id = $1
`

type SetPrimaryImageParams struct {
	ProductID uuid.UUID `json:"productId"`
	ID        uuid.UUID `json:"id"`
}

func (q *Queries) SetPrimaryImage(ctx context.Context, arg SetPrimaryImageParams) error {
	_, err := q.db.Exec(ctx, setPrimaryImage, arg.ProductID, arg.ID)
	return err
}

const updateProductImage = `-- name: UpdateProductImage :exec
UPDATE product_images 
SET 
    image_url = COALESCE($2, image_url),
    image_id = COALESCE($3, image_id),
    alt_text = COALESCE($4, alt_text),
    caption = COALESCE($5, caption),
    display_order = COALESCE($6, display_order),
    is_primary = COALESCE($7, is_primary),
    updated_at = NOW()
WHERE id = $1
`

type UpdateProductImageParams struct {
	ID           uuid.UUID `json:"id"`
	ImageUrl     *string   `json:"imageUrl"`
	ImageID      *string   `json:"imageId"`
	AltText      *string   `json:"altText"`
	Caption      *string   `json:"caption"`
	DisplayOrder *int16    `json:"displayOrder"`
	IsPrimary    *bool     `json:"isPrimary"`
}

func (q *Queries) UpdateProductImage(ctx context.Context, arg UpdateProductImageParams) error {
	_, err := q.db.Exec(ctx, updateProductImage,
		arg.ID,
		arg.ImageUrl,
		arg.ImageID,
		arg.AltText,
		arg.Caption,
		arg.DisplayOrder,
		arg.IsPrimary,
	)
	return err
}
