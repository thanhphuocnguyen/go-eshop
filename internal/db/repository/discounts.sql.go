// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: discounts.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addDiscountRule = `-- name: AddDiscountRule :one
INSERT INTO discount_rules (discount_id, rule_type, rule_value) VALUES ($1, $2, $3) RETURNING id, discount_id, rule_type, rule_value, created_at
`

type AddDiscountRuleParams struct {
	DiscountID uuid.UUID `json:"discountId"`
	RuleType   string    `json:"ruleType"`
	RuleValue  []byte    `json:"ruleValue"`
}

func (q *Queries) AddDiscountRule(ctx context.Context, arg AddDiscountRuleParams) (DiscountRule, error) {
	row := q.db.QueryRow(ctx, addDiscountRule, arg.DiscountID, arg.RuleType, arg.RuleValue)
	var i DiscountRule
	err := row.Scan(
		&i.ID,
		&i.DiscountID,
		&i.RuleType,
		&i.RuleValue,
		&i.CreatedAt,
	)
	return i, err
}

const addDiscountUsage = `-- name: AddDiscountUsage :one
INSERT INTO discount_usage (discount_id, order_id, user_id, discount_amount) VALUES ($1, $2, $3, $4) RETURNING id, discount_id, user_id, order_id, discount_amount, created_at
`

type AddDiscountUsageParams struct {
	DiscountID     uuid.UUID      `json:"discountId"`
	OrderID        uuid.UUID      `json:"orderId"`
	UserID         uuid.UUID      `json:"userId"`
	DiscountAmount pgtype.Numeric `json:"discountAmount"`
}

func (q *Queries) AddDiscountUsage(ctx context.Context, arg AddDiscountUsageParams) (DiscountUsage, error) {
	row := q.db.QueryRow(ctx, addDiscountUsage,
		arg.DiscountID,
		arg.OrderID,
		arg.UserID,
		arg.DiscountAmount,
	)
	var i DiscountUsage
	err := row.Scan(
		&i.ID,
		&i.DiscountID,
		&i.UserID,
		&i.OrderID,
		&i.DiscountAmount,
		&i.CreatedAt,
	)
	return i, err
}

const countDiscountUsages = `-- name: CountDiscountUsages :one
SELECT COUNT(*) FROM discount_usage WHERE discount_id = $1
`

func (q *Queries) CountDiscountUsages(ctx context.Context, discountID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDiscountUsages, discountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDiscounts = `-- name: CountDiscounts :one
SELECT COUNT(*) FROM discounts
`

func (q *Queries) CountDiscounts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDiscounts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDiscountsByPriority = `-- name: CountDiscountsByPriority :one
SELECT COUNT(*) FROM discounts WHERE priority = $1
`

func (q *Queries) CountDiscountsByPriority(ctx context.Context, priority *int32) (int64, error) {
	row := q.db.QueryRow(ctx, countDiscountsByPriority, priority)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDiscountsByType = `-- name: CountDiscountsByType :one
SELECT COUNT(*) FROM discounts WHERE discount_type = $1
`

func (q *Queries) CountDiscountsByType(ctx context.Context, discountType DiscountType) (int64, error) {
	row := q.db.QueryRow(ctx, countDiscountsByType, discountType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsersUsingDiscount = `-- name: CountUsersUsingDiscount :one
SELECT COUNT(DISTINCT order_id) FROM discount_usage WHERE discount_id = $1
`

func (q *Queries) CountUsersUsingDiscount(ctx context.Context, discountID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersUsingDiscount, discountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deactivateDiscount = `-- name: DeactivateDiscount :exec
UPDATE discounts SET is_active = FALSE WHERE id = $1 RETURNING id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at
`

func (q *Queries) DeactivateDiscount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateDiscount, id)
	return err
}

const decrementDiscountUsage = `-- name: DecrementDiscountUsage :exec
UPDATE discounts SET times_used = GREATEST(times_used - 1, 0) WHERE id = $1
`

func (q *Queries) DecrementDiscountUsage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, decrementDiscountUsage, id)
	return err
}

const deleteDiscount = `-- name: DeleteDiscount :exec
DELETE FROM discounts WHERE id = $1
`

func (q *Queries) DeleteDiscount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDiscount, id)
	return err
}

const deleteDiscountRules = `-- name: DeleteDiscountRules :exec
DELETE FROM discount_rules WHERE discount_id = $1
`

func (q *Queries) DeleteDiscountRules(ctx context.Context, discountID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDiscountRules, discountID)
	return err
}

const getActiveDiscounts = `-- name: GetActiveDiscounts :many
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts WHERE is_active = TRUE AND (valid_from IS NULL OR valid_from <= NOW()) AND (valid_until IS NULL OR valid_until >= NOW())
`

func (q *Queries) GetActiveDiscounts(ctx context.Context) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getActiveDiscounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountByCode = `-- name: GetDiscountByCode :one
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts WHERE code = $1 LIMIT 1
`

func (q *Queries) GetDiscountByCode(ctx context.Context, code string) (Discount, error) {
	row := q.db.QueryRow(ctx, getDiscountByCode, code)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MinOrderValue,
		&i.MaxDiscountAmount,
		&i.UsageLimit,
		&i.UsagePerUser,
		&i.TimesUsed,
		&i.IsActive,
		&i.IsStackable,
		&i.Priority,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDiscountByID = `-- name: GetDiscountByID :one
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts WHERE id = $1
`

func (q *Queries) GetDiscountByID(ctx context.Context, id uuid.UUID) (Discount, error) {
	row := q.db.QueryRow(ctx, getDiscountByID, id)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MinOrderValue,
		&i.MaxDiscountAmount,
		&i.UsageLimit,
		&i.UsagePerUser,
		&i.TimesUsed,
		&i.IsActive,
		&i.IsStackable,
		&i.Priority,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDiscountRules = `-- name: GetDiscountRules :many
SELECT id, discount_id, rule_type, rule_value, created_at FROM discount_rules WHERE discount_id = $1
`

func (q *Queries) GetDiscountRules(ctx context.Context, discountID uuid.UUID) ([]DiscountRule, error) {
	rows, err := q.db.Query(ctx, getDiscountRules, discountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscountRule{}
	for rows.Next() {
		var i DiscountRule
		if err := rows.Scan(
			&i.ID,
			&i.DiscountID,
			&i.RuleType,
			&i.RuleValue,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountUsages = `-- name: GetDiscountUsages :many
SELECT usage_limit, times_used, discount_amount, customer_name, order_id, total_price, discount_usage.created_at
FROM discounts
JOIN discount_usage ON discounts.id = discount_usage.discount_id
JOIN orders ON discount_usage.order_id = orders.id
WHERE discounts.id = $1 AND orders.status IN ('completed', 'confirmed')
`

type GetDiscountUsagesRow struct {
	UsageLimit     *int32         `json:"usageLimit"`
	TimesUsed      *int32         `json:"timesUsed"`
	DiscountAmount pgtype.Numeric `json:"discountAmount"`
	CustomerName   string         `json:"customerName"`
	OrderID        uuid.UUID      `json:"orderId"`
	TotalPrice     pgtype.Numeric `json:"totalPrice"`
	CreatedAt      time.Time      `json:"createdAt"`
}

func (q *Queries) GetDiscountUsages(ctx context.Context, id uuid.UUID) ([]GetDiscountUsagesRow, error) {
	rows, err := q.db.Query(ctx, getDiscountUsages, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDiscountUsagesRow{}
	for rows.Next() {
		var i GetDiscountUsagesRow
		if err := rows.Scan(
			&i.UsageLimit,
			&i.TimesUsed,
			&i.DiscountAmount,
			&i.CustomerName,
			&i.OrderID,
			&i.TotalPrice,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscounts = `-- name: GetDiscounts :many
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts
WHERE 
    discount_type = COALESCE($3, discounts.discount_type)
    AND is_active = COALESCE($4, TRUE)
    AND valid_from >= COALESCE($5, discounts.valid_from)
    AND valid_from <= COALESCE($6, discounts.valid_from)
    AND valid_until >= COALESCE($6, discounts.valid_until)
    AND code ILIKE '%' || COALESCE($7, discounts.code) || '%'
LIMIT $1
OFFSET $2
`

type GetDiscountsParams struct {
	Limit        int64              `json:"limit"`
	Offset       int64              `json:"offset"`
	DiscountType NullDiscountType   `json:"discountType"`
	IsActive     *bool              `json:"isActive"`
	FromDate     pgtype.Timestamptz `json:"fromDate"`
	ToDate       pgtype.Timestamptz `json:"toDate"`
	Search       *string            `json:"search"`
}

func (q *Queries) GetDiscounts(ctx context.Context, arg GetDiscountsParams) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getDiscounts,
		arg.Limit,
		arg.Offset,
		arg.DiscountType,
		arg.IsActive,
		arg.FromDate,
		arg.ToDate,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountsByPriority = `-- name: GetDiscountsByPriority :many
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts WHERE priority = $1 LIMIT $2 OFFSET $3
`

type GetDiscountsByPriorityParams struct {
	Priority *int32 `json:"priority"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

func (q *Queries) GetDiscountsByPriority(ctx context.Context, arg GetDiscountsByPriorityParams) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getDiscountsByPriority, arg.Priority, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountsByType = `-- name: GetDiscountsByType :many
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts WHERE discount_type = $1 LIMIT $2 OFFSET $3
`

type GetDiscountsByTypeParams struct {
	DiscountType DiscountType `json:"discountType"`
	Limit        int64        `json:"limit"`
	Offset       int64        `json:"offset"`
}

func (q *Queries) GetDiscountsByType(ctx context.Context, arg GetDiscountsByTypeParams) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getDiscountsByType, arg.DiscountType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredDiscounts = `-- name: GetExpiredDiscounts :many
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts WHERE is_active = TRUE AND valid_until IS NOT NULL AND valid_until < NOW()
`

func (q *Queries) GetExpiredDiscounts(ctx context.Context) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getExpiredDiscounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopUsedDiscounts = `-- name: GetTopUsedDiscounts :many
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts ORDER BY times_used DESC LIMIT $1 OFFSET $2
`

type GetTopUsedDiscountsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) GetTopUsedDiscounts(ctx context.Context, arg GetTopUsedDiscountsParams) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getTopUsedDiscounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalDiscountGiven = `-- name: GetTotalDiscountGiven :one
SELECT SUM(discount_amount) FROM discount_usage WHERE discount_id = $1
`

func (q *Queries) GetTotalDiscountGiven(ctx context.Context, discountID uuid.UUID) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getTotalDiscountGiven, discountID)
	var sum pgtype.Numeric
	err := row.Scan(&sum)
	return sum, err
}

const getUsersUsingDiscount = `-- name: GetUsersUsingDiscount :many
SELECT DISTINCT order_id FROM discount_usage WHERE discount_id = $1 LIMIT $2 OFFSET $3
`

type GetUsersUsingDiscountParams struct {
	DiscountID uuid.UUID `json:"discountId"`
	Limit      int64     `json:"limit"`
	Offset     int64     `json:"offset"`
}

func (q *Queries) GetUsersUsingDiscount(ctx context.Context, arg GetUsersUsingDiscountParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getUsersUsingDiscount, arg.DiscountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var order_id uuid.UUID
		if err := rows.Scan(&order_id); err != nil {
			return nil, err
		}
		items = append(items, order_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementDiscountUsage = `-- name: IncrementDiscountUsage :exec
UPDATE discounts SET times_used = times_used + 1 WHERE id = $1
`

func (q *Queries) IncrementDiscountUsage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementDiscountUsage, id)
	return err
}

const insertDiscount = `-- name: InsertDiscount :one
INSERT INTO discounts (code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) RETURNING id
`

type InsertDiscountParams struct {
	Code              string             `json:"code"`
	Name              string             `json:"name"`
	Description       *string            `json:"description"`
	DiscountType      DiscountType       `json:"discountType"`
	DiscountValue     pgtype.Numeric     `json:"discountValue"`
	MinOrderValue     pgtype.Numeric     `json:"minOrderValue"`
	MaxDiscountAmount pgtype.Numeric     `json:"maxDiscountAmount"`
	UsageLimit        *int32             `json:"usageLimit"`
	UsagePerUser      *int32             `json:"usagePerUser"`
	TimesUsed         *int32             `json:"timesUsed"`
	IsActive          *bool              `json:"isActive"`
	IsStackable       *bool              `json:"isStackable"`
	Priority          *int32             `json:"priority"`
	ValidFrom         pgtype.Timestamptz `json:"validFrom"`
	ValidUntil        pgtype.Timestamptz `json:"validUntil"`
}

func (q *Queries) InsertDiscount(ctx context.Context, arg InsertDiscountParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertDiscount,
		arg.Code,
		arg.Name,
		arg.Description,
		arg.DiscountType,
		arg.DiscountValue,
		arg.MinOrderValue,
		arg.MaxDiscountAmount,
		arg.UsageLimit,
		arg.UsagePerUser,
		arg.TimesUsed,
		arg.IsActive,
		arg.IsStackable,
		arg.Priority,
		arg.ValidFrom,
		arg.ValidUntil,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const reactivateDiscount = `-- name: ReactivateDiscount :exec
UPDATE discounts SET is_active = TRUE WHERE id = $1 RETURNING id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at
`

func (q *Queries) ReactivateDiscount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, reactivateDiscount, id)
	return err
}

const removeDiscountUsage = `-- name: RemoveDiscountUsage :exec
DELETE FROM discount_usage WHERE discount_id = $1 AND order_id = $2
`

type RemoveDiscountUsageParams struct {
	DiscountID uuid.UUID `json:"discountId"`
	OrderID    uuid.UUID `json:"orderId"`
}

func (q *Queries) RemoveDiscountUsage(ctx context.Context, arg RemoveDiscountUsageParams) error {
	_, err := q.db.Exec(ctx, removeDiscountUsage, arg.DiscountID, arg.OrderID)
	return err
}

const updateDiscount = `-- name: UpdateDiscount :one
UPDATE discounts SET
    code = COALESCE($2, discounts.code),
    name = COALESCE($3, discounts.name),
    "description" = COALESCE($4, discounts.description),
    discount_type = COALESCE($5, discounts.discount_type),
    discount_value = COALESCE($6, discounts.discount_value),
    min_order_value = COALESCE($7, discounts.min_order_value),
    max_discount_amount = COALESCE($8, discounts.max_discount_amount),
    usage_limit = COALESCE($9, discounts.usage_limit),
    is_active = COALESCE($10, discounts.is_active),
    is_stackable = COALESCE($11, discounts.is_stackable),
    priority = COALESCE($12, discounts.priority),
    valid_from = COALESCE($13, discounts.valid_from),
    valid_until = COALESCE($14, discounts.valid_until),
    updated_at = NOW()
WHERE id = $1 RETURNING id
`

type UpdateDiscountParams struct {
	ID                uuid.UUID          `json:"id"`
	Code              *string            `json:"code"`
	Name              *string            `json:"name"`
	Description       *string            `json:"description"`
	DiscountType      NullDiscountType   `json:"discountType"`
	DiscountValue     pgtype.Numeric     `json:"discountValue"`
	MinOrderValue     pgtype.Numeric     `json:"minOrderValue"`
	MaxDiscountAmount pgtype.Numeric     `json:"maxDiscountAmount"`
	UsageLimit        *int32             `json:"usageLimit"`
	IsActive          *bool              `json:"isActive"`
	IsStackable       *bool              `json:"isStackable"`
	Priority          *int32             `json:"priority"`
	ValidFrom         pgtype.Timestamptz `json:"validFrom"`
	ValidUntil        pgtype.Timestamptz `json:"validUntil"`
}

func (q *Queries) UpdateDiscount(ctx context.Context, arg UpdateDiscountParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updateDiscount,
		arg.ID,
		arg.Code,
		arg.Name,
		arg.Description,
		arg.DiscountType,
		arg.DiscountValue,
		arg.MinOrderValue,
		arg.MaxDiscountAmount,
		arg.UsageLimit,
		arg.IsActive,
		arg.IsStackable,
		arg.Priority,
		arg.ValidFrom,
		arg.ValidUntil,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
