// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: discounts.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addDiscountRule = `-- name: AddDiscountRule :one
INSERT INTO discount_rules (discount_id, rule_type, rule_value) VALUES ($1, $2, $3) RETURNING id, discount_id, rule_type, rule_value, created_at
`

type AddDiscountRuleParams struct {
	DiscountID uuid.UUID `json:"discountId"`
	RuleType   string    `json:"ruleType"`
	RuleValue  []byte    `json:"ruleValue"`
}

func (q *Queries) AddDiscountRule(ctx context.Context, arg AddDiscountRuleParams) (DiscountRule, error) {
	row := q.db.QueryRow(ctx, addDiscountRule, arg.DiscountID, arg.RuleType, arg.RuleValue)
	var i DiscountRule
	err := row.Scan(
		&i.ID,
		&i.DiscountID,
		&i.RuleType,
		&i.RuleValue,
		&i.CreatedAt,
	)
	return i, err
}

const addDiscountUsage = `-- name: AddDiscountUsage :one
INSERT INTO discount_usage (discount_id, order_id, user_id, discount_amount) VALUES ($1, $2, $3, $4) RETURNING id, discount_id, user_id, order_id, discount_amount, created_at
`

type AddDiscountUsageParams struct {
	DiscountID     uuid.UUID      `json:"discountId"`
	OrderID        uuid.UUID      `json:"orderId"`
	UserID         uuid.UUID      `json:"userId"`
	DiscountAmount pgtype.Numeric `json:"discountAmount"`
}

func (q *Queries) AddDiscountUsage(ctx context.Context, arg AddDiscountUsageParams) (DiscountUsage, error) {
	row := q.db.QueryRow(ctx, addDiscountUsage,
		arg.DiscountID,
		arg.OrderID,
		arg.UserID,
		arg.DiscountAmount,
	)
	var i DiscountUsage
	err := row.Scan(
		&i.ID,
		&i.DiscountID,
		&i.UserID,
		&i.OrderID,
		&i.DiscountAmount,
		&i.CreatedAt,
	)
	return i, err
}

const countAvailableDiscountsForUser = `-- name: CountAvailableDiscountsForUser :one
SELECT COUNT(*)
FROM discounts d
WHERE d.is_active = TRUE
  AND (d.valid_from IS NULL OR d.valid_from <= NOW())
  AND (d.valid_until IS NULL OR d.valid_until >= NOW())
  AND (d.usage_limit IS NULL OR d.times_used < d.usage_limit)
  AND d.id NOT IN (
    SELECT DISTINCT du.discount_id 
    FROM discount_usage du 
    JOIN orders o ON du.order_id = o.id 
    WHERE o.user_id = $1
  )
`

func (q *Queries) CountAvailableDiscountsForUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAvailableDiscountsForUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDiscountRules = `-- name: CountDiscountRules :one
SELECT COUNT(*) FROM discount_rules WHERE discount_id = $1
`

func (q *Queries) CountDiscountRules(ctx context.Context, discountID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDiscountRules, discountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDiscountRulesByType = `-- name: CountDiscountRulesByType :one
SELECT COUNT(*) FROM discount_rules WHERE discount_id = $1 AND rule_type = $2
`

type CountDiscountRulesByTypeParams struct {
	DiscountID uuid.UUID `json:"discountId"`
	RuleType   string    `json:"ruleType"`
}

func (q *Queries) CountDiscountRulesByType(ctx context.Context, arg CountDiscountRulesByTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDiscountRulesByType, arg.DiscountID, arg.RuleType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDiscountUsageByDiscountAndUser = `-- name: CountDiscountUsageByDiscountAndUser :one
SELECT COUNT(*) FROM discount_usage du
JOIN orders o ON du.order_id = o.id
WHERE du.discount_id = $1 AND o.user_id = $2
`

type CountDiscountUsageByDiscountAndUserParams struct {
	DiscountID uuid.UUID `json:"discountId"`
	UserID     uuid.UUID `json:"userId"`
}

func (q *Queries) CountDiscountUsageByDiscountAndUser(ctx context.Context, arg CountDiscountUsageByDiscountAndUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDiscountUsageByDiscountAndUser, arg.DiscountID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDiscountUsages = `-- name: CountDiscountUsages :one
SELECT COUNT(*) FROM discount_usage WHERE discount_id = $1
`

func (q *Queries) CountDiscountUsages(ctx context.Context, discountID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDiscountUsages, discountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDiscounts = `-- name: CountDiscounts :one
SELECT COUNT(*) FROM discounts
`

func (q *Queries) CountDiscounts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDiscounts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDiscountsByPriority = `-- name: CountDiscountsByPriority :one
SELECT COUNT(*) FROM discounts WHERE priority = $1
`

func (q *Queries) CountDiscountsByPriority(ctx context.Context, priority *int32) (int64, error) {
	row := q.db.QueryRow(ctx, countDiscountsByPriority, priority)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDiscountsByType = `-- name: CountDiscountsByType :one
SELECT COUNT(*) FROM discounts WHERE discount_type = $1
`

func (q *Queries) CountDiscountsByType(ctx context.Context, discountType DiscountType) (int64, error) {
	row := q.db.QueryRow(ctx, countDiscountsByType, discountType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsersUsingDiscount = `-- name: CountUsersUsingDiscount :one
SELECT COUNT(DISTINCT order_id) FROM discount_usage WHERE discount_id = $1
`

func (q *Queries) CountUsersUsingDiscount(ctx context.Context, discountID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersUsingDiscount, discountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deactivateDiscount = `-- name: DeactivateDiscount :exec
UPDATE discounts SET is_active = FALSE WHERE id = $1 RETURNING id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at
`

func (q *Queries) DeactivateDiscount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateDiscount, id)
	return err
}

const decrementDiscountUsage = `-- name: DecrementDiscountUsage :exec
UPDATE discounts SET times_used = GREATEST(times_used - 1, 0) WHERE id = $1
`

func (q *Queries) DecrementDiscountUsage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, decrementDiscountUsage, id)
	return err
}

const deleteDiscount = `-- name: DeleteDiscount :exec
DELETE FROM discounts WHERE id = $1
`

func (q *Queries) DeleteDiscount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDiscount, id)
	return err
}

const deleteDiscountRule = `-- name: DeleteDiscountRule :exec
DELETE FROM discount_rules WHERE id = $1
`

func (q *Queries) DeleteDiscountRule(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDiscountRule, id)
	return err
}

const deleteDiscountRules = `-- name: DeleteDiscountRules :exec
DELETE FROM discount_rules WHERE discount_id = $1
`

func (q *Queries) DeleteDiscountRules(ctx context.Context, discountID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDiscountRules, discountID)
	return err
}

const deleteDiscountRulesByType = `-- name: DeleteDiscountRulesByType :exec
DELETE FROM discount_rules WHERE discount_id = $1 AND rule_type = $2
`

type DeleteDiscountRulesByTypeParams struct {
	DiscountID uuid.UUID `json:"discountId"`
	RuleType   string    `json:"ruleType"`
}

func (q *Queries) DeleteDiscountRulesByType(ctx context.Context, arg DeleteDiscountRulesByTypeParams) error {
	_, err := q.db.Exec(ctx, deleteDiscountRulesByType, arg.DiscountID, arg.RuleType)
	return err
}

const getActiveDiscountRules = `-- name: GetActiveDiscountRules :many
SELECT id, discount_id, rule_type, rule_value, created_at FROM discount_rules
WHERE discount_id = $1
AND rule_type = COALESCE($4, rule_type)
LIMIT $2 OFFSET $3
`

type GetActiveDiscountRulesParams struct {
	DiscountID uuid.UUID `json:"discountId"`
	Limit      int64     `json:"limit"`
	Offset     int64     `json:"offset"`
	RuleType   *string   `json:"ruleType"`
}

func (q *Queries) GetActiveDiscountRules(ctx context.Context, arg GetActiveDiscountRulesParams) ([]DiscountRule, error) {
	rows, err := q.db.Query(ctx, getActiveDiscountRules,
		arg.DiscountID,
		arg.Limit,
		arg.Offset,
		arg.RuleType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscountRule{}
	for rows.Next() {
		var i DiscountRule
		if err := rows.Scan(
			&i.ID,
			&i.DiscountID,
			&i.RuleType,
			&i.RuleValue,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveDiscounts = `-- name: GetActiveDiscounts :many
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts WHERE is_active = TRUE AND (valid_from IS NULL OR valid_from <= NOW()) AND (valid_until IS NULL OR valid_until >= NOW())
`

func (q *Queries) GetActiveDiscounts(ctx context.Context) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getActiveDiscounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableDiscountsForUser = `-- name: GetAvailableDiscountsForUser :many
SELECT d.id, d.code, d.name, d.description, d.discount_type, d.discount_value, d.min_order_value, d.max_discount_amount, d.usage_limit, d.usage_per_user, d.times_used, d.is_active, d.is_stackable, d.priority, d.valid_from, d.valid_until, d.created_at, d.updated_at 
FROM discounts d
LEFT JOIN (
  SELECT 
    du.discount_id, 
    COUNT(*) as user_usage_count
  FROM discount_usage du
  JOIN orders o ON du.order_id = o.id
  WHERE o.user_id = $1
  GROUP BY du.discount_id
) user_usage ON d.id = user_usage.discount_id
WHERE d.is_active = TRUE
  AND (d.valid_from IS NULL OR d.valid_from <= NOW())
  AND (d.valid_until IS NULL OR d.valid_until >= NOW())
  AND (d.usage_limit IS NULL OR d.times_used < d.usage_limit)
  AND (d.usage_per_user IS NULL OR COALESCE(user_usage.user_usage_count, 0) < d.usage_per_user)
ORDER BY d.priority DESC, d.discount_value DESC
`

func (q *Queries) GetAvailableDiscountsForUser(ctx context.Context, userID uuid.UUID) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getAvailableDiscountsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountByCode = `-- name: GetDiscountByCode :one
SELECT discounts.id, discounts.code, discounts.name, discounts.description, discounts.discount_type, discounts.discount_value, discounts.min_order_value, discounts.max_discount_amount, discounts.usage_limit, discounts.usage_per_user, discounts.times_used, discounts.is_active, discounts.is_stackable, discounts.priority, discounts.valid_from, discounts.valid_until, discounts.created_at, discounts.updated_at, JSONB_AGG(DISTINCT discount_rules.*) FROM discounts
LEFT JOIN discount_rules ON discounts.id = discount_rules.discount_id
WHERE code = $1 
GROUP BY discounts.id
LIMIT 1
`

type GetDiscountByCodeRow struct {
	ID                uuid.UUID          `json:"id"`
	Code              string             `json:"code"`
	Name              string             `json:"name"`
	Description       *string            `json:"description"`
	DiscountType      DiscountType       `json:"discountType"`
	DiscountValue     pgtype.Numeric     `json:"discountValue"`
	MinOrderValue     pgtype.Numeric     `json:"minOrderValue"`
	MaxDiscountAmount pgtype.Numeric     `json:"maxDiscountAmount"`
	UsageLimit        *int32             `json:"usageLimit"`
	UsagePerUser      *int32             `json:"usagePerUser"`
	TimesUsed         int32              `json:"timesUsed"`
	IsActive          bool               `json:"isActive"`
	IsStackable       bool               `json:"isStackable"`
	Priority          *int32             `json:"priority"`
	ValidFrom         time.Time          `json:"validFrom"`
	ValidUntil        pgtype.Timestamptz `json:"validUntil"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
	JsonbAgg          []byte             `json:"jsonbAgg"`
}

func (q *Queries) GetDiscountByCode(ctx context.Context, code string) (GetDiscountByCodeRow, error) {
	row := q.db.QueryRow(ctx, getDiscountByCode, code)
	var i GetDiscountByCodeRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MinOrderValue,
		&i.MaxDiscountAmount,
		&i.UsageLimit,
		&i.UsagePerUser,
		&i.TimesUsed,
		&i.IsActive,
		&i.IsStackable,
		&i.Priority,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.JsonbAgg,
	)
	return i, err
}

const getDiscountByCodes = `-- name: GetDiscountByCodes :many
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts WHERE code = ANY($1)
`

func (q *Queries) GetDiscountByCodes(ctx context.Context, code []string) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getDiscountByCodes, code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountByID = `-- name: GetDiscountByID :one
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts WHERE id = $1
`

func (q *Queries) GetDiscountByID(ctx context.Context, id uuid.UUID) (Discount, error) {
	row := q.db.QueryRow(ctx, getDiscountByID, id)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MinOrderValue,
		&i.MaxDiscountAmount,
		&i.UsageLimit,
		&i.UsagePerUser,
		&i.TimesUsed,
		&i.IsActive,
		&i.IsStackable,
		&i.Priority,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDiscountRuleByID = `-- name: GetDiscountRuleByID :one
SELECT id, discount_id, rule_type, rule_value, created_at FROM discount_rules WHERE id = $1
`

func (q *Queries) GetDiscountRuleByID(ctx context.Context, id uuid.UUID) (DiscountRule, error) {
	row := q.db.QueryRow(ctx, getDiscountRuleByID, id)
	var i DiscountRule
	err := row.Scan(
		&i.ID,
		&i.DiscountID,
		&i.RuleType,
		&i.RuleValue,
		&i.CreatedAt,
	)
	return i, err
}

const getDiscountRules = `-- name: GetDiscountRules :many
SELECT id, discount_id, rule_type, rule_value, created_at FROM discount_rules WHERE discount_id = $1
`

func (q *Queries) GetDiscountRules(ctx context.Context, discountID uuid.UUID) ([]DiscountRule, error) {
	rows, err := q.db.Query(ctx, getDiscountRules, discountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiscountRule{}
	for rows.Next() {
		var i DiscountRule
		if err := rows.Scan(
			&i.ID,
			&i.DiscountID,
			&i.RuleType,
			&i.RuleValue,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountUsages = `-- name: GetDiscountUsages :many
SELECT usage_limit, times_used, discount_amount, customer_name, order_id, total_price, discount_usage.created_at
FROM discounts
JOIN discount_usage ON discounts.id = discount_usage.discount_id
JOIN orders ON discount_usage.order_id = orders.id
WHERE discounts.id = $1 AND orders.status IN ('completed', 'confirmed')
`

type GetDiscountUsagesRow struct {
	UsageLimit     *int32         `json:"usageLimit"`
	TimesUsed      int32          `json:"timesUsed"`
	DiscountAmount pgtype.Numeric `json:"discountAmount"`
	CustomerName   string         `json:"customerName"`
	OrderID        uuid.UUID      `json:"orderId"`
	TotalPrice     pgtype.Numeric `json:"totalPrice"`
	CreatedAt      time.Time      `json:"createdAt"`
}

func (q *Queries) GetDiscountUsages(ctx context.Context, id uuid.UUID) ([]GetDiscountUsagesRow, error) {
	rows, err := q.db.Query(ctx, getDiscountUsages, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDiscountUsagesRow{}
	for rows.Next() {
		var i GetDiscountUsagesRow
		if err := rows.Scan(
			&i.UsageLimit,
			&i.TimesUsed,
			&i.DiscountAmount,
			&i.CustomerName,
			&i.OrderID,
			&i.TotalPrice,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountUsagesByUser = `-- name: GetDiscountUsagesByUser :many
SELECT usage_limit, times_used, discount_amount, customer_name, order_id, total_price, discount_usage.created_at
FROM discounts
JOIN discount_usage ON discounts.id = discount_usage.discount_id
JOIN orders ON discount_usage.order_id = orders.id
WHERE discounts.id = $1 AND discount_usage.user_id = $2 AND orders.status IN ('completed', 'confirmed')
`

type GetDiscountUsagesByUserParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"userId"`
}

type GetDiscountUsagesByUserRow struct {
	UsageLimit     *int32         `json:"usageLimit"`
	TimesUsed      int32          `json:"timesUsed"`
	DiscountAmount pgtype.Numeric `json:"discountAmount"`
	CustomerName   string         `json:"customerName"`
	OrderID        uuid.UUID      `json:"orderId"`
	TotalPrice     pgtype.Numeric `json:"totalPrice"`
	CreatedAt      time.Time      `json:"createdAt"`
}

func (q *Queries) GetDiscountUsagesByUser(ctx context.Context, arg GetDiscountUsagesByUserParams) ([]GetDiscountUsagesByUserRow, error) {
	rows, err := q.db.Query(ctx, getDiscountUsagesByUser, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDiscountUsagesByUserRow{}
	for rows.Next() {
		var i GetDiscountUsagesByUserRow
		if err := rows.Scan(
			&i.UsageLimit,
			&i.TimesUsed,
			&i.DiscountAmount,
			&i.CustomerName,
			&i.OrderID,
			&i.TotalPrice,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscounts = `-- name: GetDiscounts :many
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts
WHERE 
    discount_type = COALESCE($3, discounts.discount_type)
    AND is_active = COALESCE($4, TRUE)
    AND valid_from >= COALESCE($5, discounts.valid_from)
    AND valid_from <= COALESCE($6, discounts.valid_from)
    AND valid_until >= COALESCE($6, discounts.valid_until)
    AND code ILIKE COALESCE($7, discounts.code)
LIMIT $1
OFFSET $2
`

type GetDiscountsParams struct {
	Limit        int64              `json:"limit"`
	Offset       int64              `json:"offset"`
	DiscountType NullDiscountType   `json:"discountType"`
	IsActive     *bool              `json:"isActive"`
	FromDate     pgtype.Timestamptz `json:"fromDate"`
	ToDate       pgtype.Timestamptz `json:"toDate"`
	Search       *string            `json:"search"`
}

func (q *Queries) GetDiscounts(ctx context.Context, arg GetDiscountsParams) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getDiscounts,
		arg.Limit,
		arg.Offset,
		arg.DiscountType,
		arg.IsActive,
		arg.FromDate,
		arg.ToDate,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountsByPriority = `-- name: GetDiscountsByPriority :many
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts WHERE priority = $1 LIMIT $2 OFFSET $3
`

type GetDiscountsByPriorityParams struct {
	Priority *int32 `json:"priority"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

func (q *Queries) GetDiscountsByPriority(ctx context.Context, arg GetDiscountsByPriorityParams) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getDiscountsByPriority, arg.Priority, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountsByType = `-- name: GetDiscountsByType :many
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts WHERE discount_type = $1 LIMIT $2 OFFSET $3
`

type GetDiscountsByTypeParams struct {
	DiscountType DiscountType `json:"discountType"`
	Limit        int64        `json:"limit"`
	Offset       int64        `json:"offset"`
}

func (q *Queries) GetDiscountsByType(ctx context.Context, arg GetDiscountsByTypeParams) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getDiscountsByType, arg.DiscountType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountsWithRules = `-- name: GetDiscountsWithRules :many
SELECT d.id, d.code, d.name, d.description, d.discount_type, d.discount_value, d.min_order_value, d.max_discount_amount, d.usage_limit, d.usage_per_user, d.times_used, d.is_active, d.is_stackable, d.priority, d.valid_from, d.valid_until, d.created_at, d.updated_at, dr.rule_type, dr.rule_value
FROM discounts d
LEFT JOIN discount_rules dr ON d.id = dr.discount_id
WHERE d.id = COALESCE($3, d.id)
AND dr.rule_type = COALESCE($4, dr.rule_type)
LIMIT $1 OFFSET $2
`

type GetDiscountsWithRulesParams struct {
	Limit      int64       `json:"limit"`
	Offset     int64       `json:"offset"`
	DiscountID pgtype.UUID `json:"discountId"`
	RuleType   *string     `json:"ruleType"`
}

type GetDiscountsWithRulesRow struct {
	ID                uuid.UUID          `json:"id"`
	Code              string             `json:"code"`
	Name              string             `json:"name"`
	Description       *string            `json:"description"`
	DiscountType      DiscountType       `json:"discountType"`
	DiscountValue     pgtype.Numeric     `json:"discountValue"`
	MinOrderValue     pgtype.Numeric     `json:"minOrderValue"`
	MaxDiscountAmount pgtype.Numeric     `json:"maxDiscountAmount"`
	UsageLimit        *int32             `json:"usageLimit"`
	UsagePerUser      *int32             `json:"usagePerUser"`
	TimesUsed         int32              `json:"timesUsed"`
	IsActive          bool               `json:"isActive"`
	IsStackable       bool               `json:"isStackable"`
	Priority          *int32             `json:"priority"`
	ValidFrom         time.Time          `json:"validFrom"`
	ValidUntil        pgtype.Timestamptz `json:"validUntil"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
	RuleType          *string            `json:"ruleType"`
	RuleValue         []byte             `json:"ruleValue"`
}

func (q *Queries) GetDiscountsWithRules(ctx context.Context, arg GetDiscountsWithRulesParams) ([]GetDiscountsWithRulesRow, error) {
	rows, err := q.db.Query(ctx, getDiscountsWithRules,
		arg.Limit,
		arg.Offset,
		arg.DiscountID,
		arg.RuleType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDiscountsWithRulesRow{}
	for rows.Next() {
		var i GetDiscountsWithRulesRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RuleType,
			&i.RuleValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountsWithUsageStatsByUserId = `-- name: GetDiscountsWithUsageStatsByUserId :many
SELECT d.id, d.code, d.name, d.description, d.discount_type, d.discount_value, d.min_order_value, d.max_discount_amount, d.usage_limit, d.usage_per_user, d.times_used, d.is_active, d.is_stackable, d.priority, d.valid_from, d.valid_until, d.created_at, d.updated_at, 
       COUNT(du.id) AS total_usages, 
       SUM(du.discount_amount) AS total_discount_given
FROM discounts d
LEFT JOIN discount_usage du ON d.id = du.discount_id
WHERE du.user_id = $1 AND d.code = ANY($2)
GROUP BY d.id
`

type GetDiscountsWithUsageStatsByUserIdParams struct {
	UserID uuid.UUID `json:"userId"`
	Code   []string  `json:"code"`
}

type GetDiscountsWithUsageStatsByUserIdRow struct {
	ID                 uuid.UUID          `json:"id"`
	Code               string             `json:"code"`
	Name               string             `json:"name"`
	Description        *string            `json:"description"`
	DiscountType       DiscountType       `json:"discountType"`
	DiscountValue      pgtype.Numeric     `json:"discountValue"`
	MinOrderValue      pgtype.Numeric     `json:"minOrderValue"`
	MaxDiscountAmount  pgtype.Numeric     `json:"maxDiscountAmount"`
	UsageLimit         *int32             `json:"usageLimit"`
	UsagePerUser       *int32             `json:"usagePerUser"`
	TimesUsed          int32              `json:"timesUsed"`
	IsActive           bool               `json:"isActive"`
	IsStackable        bool               `json:"isStackable"`
	Priority           *int32             `json:"priority"`
	ValidFrom          time.Time          `json:"validFrom"`
	ValidUntil         pgtype.Timestamptz `json:"validUntil"`
	CreatedAt          time.Time          `json:"createdAt"`
	UpdatedAt          time.Time          `json:"updatedAt"`
	TotalUsages        int64              `json:"totalUsages"`
	TotalDiscountGiven pgtype.Numeric     `json:"totalDiscountGiven"`
}

func (q *Queries) GetDiscountsWithUsageStatsByUserId(ctx context.Context, arg GetDiscountsWithUsageStatsByUserIdParams) ([]GetDiscountsWithUsageStatsByUserIdRow, error) {
	rows, err := q.db.Query(ctx, getDiscountsWithUsageStatsByUserId, arg.UserID, arg.Code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDiscountsWithUsageStatsByUserIdRow{}
	for rows.Next() {
		var i GetDiscountsWithUsageStatsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalUsages,
			&i.TotalDiscountGiven,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredDiscounts = `-- name: GetExpiredDiscounts :many
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts WHERE is_active = TRUE AND valid_until IS NOT NULL AND valid_until < NOW()
`

func (q *Queries) GetExpiredDiscounts(ctx context.Context) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getExpiredDiscounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderDiscounts = `-- name: GetOrderDiscounts :many
SELECT d.id, d.code, d.name, d.description, d.discount_type, d.discount_value, d.min_order_value, d.max_discount_amount, d.usage_limit, d.usage_per_user, d.times_used, d.is_active, d.is_stackable, d.priority, d.valid_from, d.valid_until, d.created_at, d.updated_at
FROM discounts d
JOIN discount_usage du ON d.id = du.discount_id
WHERE du.order_id = $1
`

func (q *Queries) GetOrderDiscounts(ctx context.Context, orderID uuid.UUID) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getOrderDiscounts, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopUsedDiscounts = `-- name: GetTopUsedDiscounts :many
SELECT id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at FROM discounts ORDER BY times_used DESC LIMIT $1 OFFSET $2
`

type GetTopUsedDiscountsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) GetTopUsedDiscounts(ctx context.Context, arg GetTopUsedDiscountsParams) ([]Discount, error) {
	rows, err := q.db.Query(ctx, getTopUsedDiscounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MinOrderValue,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsagePerUser,
			&i.TimesUsed,
			&i.IsActive,
			&i.IsStackable,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalDiscountGiven = `-- name: GetTotalDiscountGiven :one
SELECT SUM(discount_amount) FROM discount_usage WHERE discount_id = $1
`

func (q *Queries) GetTotalDiscountGiven(ctx context.Context, discountID uuid.UUID) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getTotalDiscountGiven, discountID)
	var sum pgtype.Numeric
	err := row.Scan(&sum)
	return sum, err
}

const getUsersUsingDiscount = `-- name: GetUsersUsingDiscount :many
SELECT DISTINCT order_id FROM discount_usage WHERE discount_id = $1 LIMIT $2 OFFSET $3
`

type GetUsersUsingDiscountParams struct {
	DiscountID uuid.UUID `json:"discountId"`
	Limit      int64     `json:"limit"`
	Offset     int64     `json:"offset"`
}

func (q *Queries) GetUsersUsingDiscount(ctx context.Context, arg GetUsersUsingDiscountParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getUsersUsingDiscount, arg.DiscountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var order_id uuid.UUID
		if err := rows.Scan(&order_id); err != nil {
			return nil, err
		}
		items = append(items, order_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementDiscountUsage = `-- name: IncrementDiscountUsage :exec
UPDATE discounts SET times_used = times_used + 1 WHERE id = $1
`

func (q *Queries) IncrementDiscountUsage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementDiscountUsage, id)
	return err
}

const insertDiscount = `-- name: InsertDiscount :one
INSERT INTO discounts (code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) RETURNING id
`

type InsertDiscountParams struct {
	Code              string             `json:"code"`
	Name              string             `json:"name"`
	Description       *string            `json:"description"`
	DiscountType      DiscountType       `json:"discountType"`
	DiscountValue     pgtype.Numeric     `json:"discountValue"`
	MinOrderValue     pgtype.Numeric     `json:"minOrderValue"`
	MaxDiscountAmount pgtype.Numeric     `json:"maxDiscountAmount"`
	UsageLimit        *int32             `json:"usageLimit"`
	UsagePerUser      *int32             `json:"usagePerUser"`
	TimesUsed         int32              `json:"timesUsed"`
	IsActive          bool               `json:"isActive"`
	IsStackable       bool               `json:"isStackable"`
	Priority          *int32             `json:"priority"`
	ValidFrom         pgtype.Timestamptz `json:"validFrom"`
	ValidUntil        pgtype.Timestamptz `json:"validUntil"`
}

func (q *Queries) InsertDiscount(ctx context.Context, arg InsertDiscountParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertDiscount,
		arg.Code,
		arg.Name,
		arg.Description,
		arg.DiscountType,
		arg.DiscountValue,
		arg.MinOrderValue,
		arg.MaxDiscountAmount,
		arg.UsageLimit,
		arg.UsagePerUser,
		arg.TimesUsed,
		arg.IsActive,
		arg.IsStackable,
		arg.Priority,
		arg.ValidFrom,
		arg.ValidUntil,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const insertDiscountRule = `-- name: InsertDiscountRule :one
INSERT INTO discount_rules (discount_id, rule_type, rule_value) VALUES ($1, $2, $3) RETURNING id
`

type InsertDiscountRuleParams struct {
	DiscountID uuid.UUID `json:"discountId"`
	RuleType   string    `json:"ruleType"`
	RuleValue  []byte    `json:"ruleValue"`
}

func (q *Queries) InsertDiscountRule(ctx context.Context, arg InsertDiscountRuleParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertDiscountRule, arg.DiscountID, arg.RuleType, arg.RuleValue)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const reactivateDiscount = `-- name: ReactivateDiscount :exec
UPDATE discounts SET is_active = TRUE WHERE id = $1 RETURNING id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at
`

func (q *Queries) ReactivateDiscount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, reactivateDiscount, id)
	return err
}

const removeDiscountUsage = `-- name: RemoveDiscountUsage :exec
DELETE FROM discount_usage WHERE discount_id = $1 AND order_id = $2
`

type RemoveDiscountUsageParams struct {
	DiscountID uuid.UUID `json:"discountId"`
	OrderID    uuid.UUID `json:"orderId"`
}

func (q *Queries) RemoveDiscountUsage(ctx context.Context, arg RemoveDiscountUsageParams) error {
	_, err := q.db.Exec(ctx, removeDiscountUsage, arg.DiscountID, arg.OrderID)
	return err
}

type SeedDiscountsParams struct {
	Code              string             `json:"code"`
	Name              string             `json:"name"`
	Description       *string            `json:"description"`
	DiscountType      DiscountType       `json:"discountType"`
	DiscountValue     pgtype.Numeric     `json:"discountValue"`
	MinOrderValue     pgtype.Numeric     `json:"minOrderValue"`
	MaxDiscountAmount pgtype.Numeric     `json:"maxDiscountAmount"`
	UsageLimit        *int32             `json:"usageLimit"`
	UsagePerUser      *int32             `json:"usagePerUser"`
	IsActive          bool               `json:"isActive"`
	IsStackable       bool               `json:"isStackable"`
	Priority          *int32             `json:"priority"`
	ValidFrom         pgtype.Timestamptz `json:"validFrom"`
	ValidUntil        pgtype.Timestamptz `json:"validUntil"`
}

const updateDiscount = `-- name: UpdateDiscount :one
UPDATE discounts SET
    code = COALESCE($2, discounts.code),
    name = COALESCE($3, discounts.name),
    "description" = COALESCE($4, discounts.description),
    discount_type = COALESCE($5, discounts.discount_type),
    discount_value = COALESCE($6, discounts.discount_value),
    min_order_value = COALESCE($7, discounts.min_order_value),
    max_discount_amount = COALESCE($8, discounts.max_discount_amount),
    usage_limit = COALESCE($9, discounts.usage_limit),
    is_active = COALESCE($10, discounts.is_active),
    is_stackable = COALESCE($11, discounts.is_stackable),
    priority = COALESCE($12, discounts.priority),
    valid_from = COALESCE($13, discounts.valid_from),
    valid_until = COALESCE($14, discounts.valid_until),
    usage_per_user = COALESCE($15, discounts.usage_per_user),
    updated_at = NOW()
WHERE id = $1 RETURNING id, code, name, description, discount_type, discount_value, min_order_value, max_discount_amount, usage_limit, usage_per_user, times_used, is_active, is_stackable, priority, valid_from, valid_until, created_at, updated_at
`

type UpdateDiscountParams struct {
	ID                uuid.UUID          `json:"id"`
	Code              *string            `json:"code"`
	Name              *string            `json:"name"`
	Description       *string            `json:"description"`
	DiscountType      NullDiscountType   `json:"discountType"`
	DiscountValue     pgtype.Numeric     `json:"discountValue"`
	MinOrderValue     pgtype.Numeric     `json:"minOrderValue"`
	MaxDiscountAmount pgtype.Numeric     `json:"maxDiscountAmount"`
	UsageLimit        *int32             `json:"usageLimit"`
	IsActive          *bool              `json:"isActive"`
	IsStackable       *bool              `json:"isStackable"`
	Priority          *int32             `json:"priority"`
	ValidFrom         pgtype.Timestamptz `json:"validFrom"`
	ValidUntil        pgtype.Timestamptz `json:"validUntil"`
	UsagePerUser      *int32             `json:"usagePerUser"`
}

func (q *Queries) UpdateDiscount(ctx context.Context, arg UpdateDiscountParams) (Discount, error) {
	row := q.db.QueryRow(ctx, updateDiscount,
		arg.ID,
		arg.Code,
		arg.Name,
		arg.Description,
		arg.DiscountType,
		arg.DiscountValue,
		arg.MinOrderValue,
		arg.MaxDiscountAmount,
		arg.UsageLimit,
		arg.IsActive,
		arg.IsStackable,
		arg.Priority,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.UsagePerUser,
	)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MinOrderValue,
		&i.MaxDiscountAmount,
		&i.UsageLimit,
		&i.UsagePerUser,
		&i.TimesUsed,
		&i.IsActive,
		&i.IsStackable,
		&i.Priority,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDiscountRule = `-- name: UpdateDiscountRule :one
UPDATE discount_rules SET
    rule_type = COALESCE($2, discount_rules.rule_type),
    rule_value = COALESCE($3, discount_rules.rule_value)
WHERE id = $1 RETURNING id, discount_id, rule_type, rule_value, created_at
`

type UpdateDiscountRuleParams struct {
	ID        uuid.UUID `json:"id"`
	RuleType  *string   `json:"ruleType"`
	RuleValue []byte    `json:"ruleValue"`
}

func (q *Queries) UpdateDiscountRule(ctx context.Context, arg UpdateDiscountRuleParams) (DiscountRule, error) {
	row := q.db.QueryRow(ctx, updateDiscountRule, arg.ID, arg.RuleType, arg.RuleValue)
	var i DiscountRule
	err := row.Scan(
		&i.ID,
		&i.DiscountID,
		&i.RuleType,
		&i.RuleValue,
		&i.CreatedAt,
	)
	return i, err
}
