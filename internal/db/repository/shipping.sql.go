// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: shipping.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countShippingMethods = `-- name: CountShippingMethods :one
SELECT COUNT(*) FROM shipping_methods
`

func (q *Queries) CountShippingMethods(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countShippingMethods)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countShippingRates = `-- name: CountShippingRates :one
SELECT COUNT(*) FROM shipping_rates
`

func (q *Queries) CountShippingRates(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countShippingRates)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countShippingZones = `-- name: CountShippingZones :one
SELECT COUNT(*) FROM shipping_zones
`

func (q *Queries) CountShippingZones(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countShippingZones)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createShippingMethod = `-- name: CreateShippingMethod :one
INSERT INTO shipping_methods (name, description, is_active, requires_address, estimated_delivery_time, icon_url) 
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, name, description, is_active, requires_address, estimated_delivery_time, icon_url, created_at, updated_at
`

type CreateShippingMethodParams struct {
	Name                  string  `json:"name"`
	Description           *string `json:"description"`
	IsActive              bool    `json:"isActive"`
	RequiresAddress       bool    `json:"requiresAddress"`
	EstimatedDeliveryTime *string `json:"estimatedDeliveryTime"`
	IconUrl               *string `json:"iconUrl"`
}

func (q *Queries) CreateShippingMethod(ctx context.Context, arg CreateShippingMethodParams) (ShippingMethod, error) {
	row := q.db.QueryRow(ctx, createShippingMethod,
		arg.Name,
		arg.Description,
		arg.IsActive,
		arg.RequiresAddress,
		arg.EstimatedDeliveryTime,
		arg.IconUrl,
	)
	var i ShippingMethod
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.RequiresAddress,
		&i.EstimatedDeliveryTime,
		&i.IconUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createShippingRate = `-- name: CreateShippingRate :one
INSERT INTO shipping_rates (shipping_method_id, shipping_zone_id, name, base_rate, min_order_amount, max_order_amount, free_shipping_threshold, is_active) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, shipping_method_id, shipping_zone_id, name, base_rate, min_order_amount, max_order_amount, free_shipping_threshold, is_active, created_at, updated_at
`

type CreateShippingRateParams struct {
	ShippingMethodID      uuid.UUID      `json:"shippingMethodId"`
	ShippingZoneID        uuid.UUID      `json:"shippingZoneId"`
	Name                  string         `json:"name"`
	BaseRate              pgtype.Numeric `json:"baseRate"`
	MinOrderAmount        pgtype.Numeric `json:"minOrderAmount"`
	MaxOrderAmount        pgtype.Numeric `json:"maxOrderAmount"`
	FreeShippingThreshold pgtype.Numeric `json:"freeShippingThreshold"`
	IsActive              bool           `json:"isActive"`
}

// SHIPPING RATES
func (q *Queries) CreateShippingRate(ctx context.Context, arg CreateShippingRateParams) (ShippingRate, error) {
	row := q.db.QueryRow(ctx, createShippingRate,
		arg.ShippingMethodID,
		arg.ShippingZoneID,
		arg.Name,
		arg.BaseRate,
		arg.MinOrderAmount,
		arg.MaxOrderAmount,
		arg.FreeShippingThreshold,
		arg.IsActive,
	)
	var i ShippingRate
	err := row.Scan(
		&i.ID,
		&i.ShippingMethodID,
		&i.ShippingZoneID,
		&i.Name,
		&i.BaseRate,
		&i.MinOrderAmount,
		&i.MaxOrderAmount,
		&i.FreeShippingThreshold,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createShippingZone = `-- name: CreateShippingZone :one
INSERT INTO shipping_zones (name, description, countries, states, zip_codes, is_active) 
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, name, description, countries, states, zip_codes, is_active, created_at, updated_at
`

type CreateShippingZoneParams struct {
	Name        string   `json:"name"`
	Description *string  `json:"description"`
	Countries   []string `json:"countries"`
	States      []string `json:"states"`
	ZipCodes    []string `json:"zipCodes"`
	IsActive    bool     `json:"isActive"`
}

// SHIPPING ZONES
func (q *Queries) CreateShippingZone(ctx context.Context, arg CreateShippingZoneParams) (ShippingZone, error) {
	row := q.db.QueryRow(ctx, createShippingZone,
		arg.Name,
		arg.Description,
		arg.Countries,
		arg.States,
		arg.ZipCodes,
		arg.IsActive,
	)
	var i ShippingZone
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Countries,
		&i.States,
		&i.ZipCodes,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteShippingMethod = `-- name: DeleteShippingMethod :exec
DELETE FROM shipping_methods WHERE id = $1
`

func (q *Queries) DeleteShippingMethod(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteShippingMethod, id)
	return err
}

const deleteShippingRate = `-- name: DeleteShippingRate :exec
DELETE FROM shipping_rates WHERE id = $1
`

func (q *Queries) DeleteShippingRate(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteShippingRate, id)
	return err
}

const deleteShippingZone = `-- name: DeleteShippingZone :exec
DELETE FROM shipping_zones WHERE id = $1
`

func (q *Queries) DeleteShippingZone(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteShippingZone, id)
	return err
}

const getShippingMethodByID = `-- name: GetShippingMethodByID :one
SELECT id, name, description, is_active, requires_address, estimated_delivery_time, icon_url, created_at, updated_at FROM shipping_methods WHERE id = $1
`

func (q *Queries) GetShippingMethodByID(ctx context.Context, id uuid.UUID) (ShippingMethod, error) {
	row := q.db.QueryRow(ctx, getShippingMethodByID, id)
	var i ShippingMethod
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.RequiresAddress,
		&i.EstimatedDeliveryTime,
		&i.IconUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShippingMethods = `-- name: GetShippingMethods :many
SELECT id, name, description, is_active, requires_address, estimated_delivery_time, icon_url, created_at, updated_at FROM shipping_methods WHERE is_active = COALESCE($1, TRUE) ORDER BY name
`

func (q *Queries) GetShippingMethods(ctx context.Context, isActive *bool) ([]ShippingMethod, error) {
	rows, err := q.db.Query(ctx, getShippingMethods, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShippingMethod{}
	for rows.Next() {
		var i ShippingMethod
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.RequiresAddress,
			&i.EstimatedDeliveryTime,
			&i.IconUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShippingRateByID = `-- name: GetShippingRateByID :one
SELECT sr.id, sr.shipping_method_id, sr.shipping_zone_id, sr.name, sr.base_rate, sr.min_order_amount, sr.max_order_amount, sr.free_shipping_threshold, sr.is_active, sr.created_at, sr.updated_at, sm.name as method_name, sz.name as zone_name
FROM shipping_rates sr
JOIN shipping_methods sm ON sr.shipping_method_id = sm.id
JOIN shipping_zones sz ON sr.shipping_zone_id = sz.id
WHERE sr.id = $1
`

type GetShippingRateByIDRow struct {
	ID                    uuid.UUID      `json:"id"`
	ShippingMethodID      uuid.UUID      `json:"shippingMethodId"`
	ShippingZoneID        uuid.UUID      `json:"shippingZoneId"`
	Name                  string         `json:"name"`
	BaseRate              pgtype.Numeric `json:"baseRate"`
	MinOrderAmount        pgtype.Numeric `json:"minOrderAmount"`
	MaxOrderAmount        pgtype.Numeric `json:"maxOrderAmount"`
	FreeShippingThreshold pgtype.Numeric `json:"freeShippingThreshold"`
	IsActive              bool           `json:"isActive"`
	CreatedAt             time.Time      `json:"createdAt"`
	UpdatedAt             time.Time      `json:"updatedAt"`
	MethodName            string         `json:"methodName"`
	ZoneName              string         `json:"zoneName"`
}

func (q *Queries) GetShippingRateByID(ctx context.Context, id uuid.UUID) (GetShippingRateByIDRow, error) {
	row := q.db.QueryRow(ctx, getShippingRateByID, id)
	var i GetShippingRateByIDRow
	err := row.Scan(
		&i.ID,
		&i.ShippingMethodID,
		&i.ShippingZoneID,
		&i.Name,
		&i.BaseRate,
		&i.MinOrderAmount,
		&i.MaxOrderAmount,
		&i.FreeShippingThreshold,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MethodName,
		&i.ZoneName,
	)
	return i, err
}

const getShippingRates = `-- name: GetShippingRates :many
SELECT sr.id, sr.shipping_method_id, sr.shipping_zone_id, sr.name, sr.base_rate, sr.min_order_amount, sr.max_order_amount, sr.free_shipping_threshold, sr.is_active, sr.created_at, sr.updated_at, sm.name as method_name, sz.name as zone_name
FROM shipping_rates sr
JOIN shipping_methods sm ON sr.shipping_method_id = sm.id
JOIN shipping_zones sz ON sr.shipping_zone_id = sz.id
WHERE sr.is_active = COALESCE($1, TRUE)
ORDER BY sr.base_rate
`

type GetShippingRatesRow struct {
	ID                    uuid.UUID      `json:"id"`
	ShippingMethodID      uuid.UUID      `json:"shippingMethodId"`
	ShippingZoneID        uuid.UUID      `json:"shippingZoneId"`
	Name                  string         `json:"name"`
	BaseRate              pgtype.Numeric `json:"baseRate"`
	MinOrderAmount        pgtype.Numeric `json:"minOrderAmount"`
	MaxOrderAmount        pgtype.Numeric `json:"maxOrderAmount"`
	FreeShippingThreshold pgtype.Numeric `json:"freeShippingThreshold"`
	IsActive              bool           `json:"isActive"`
	CreatedAt             time.Time      `json:"createdAt"`
	UpdatedAt             time.Time      `json:"updatedAt"`
	MethodName            string         `json:"methodName"`
	ZoneName              string         `json:"zoneName"`
}

func (q *Queries) GetShippingRates(ctx context.Context, isActive *bool) ([]GetShippingRatesRow, error) {
	rows, err := q.db.Query(ctx, getShippingRates, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShippingRatesRow{}
	for rows.Next() {
		var i GetShippingRatesRow
		if err := rows.Scan(
			&i.ID,
			&i.ShippingMethodID,
			&i.ShippingZoneID,
			&i.Name,
			&i.BaseRate,
			&i.MinOrderAmount,
			&i.MaxOrderAmount,
			&i.FreeShippingThreshold,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MethodName,
			&i.ZoneName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShippingRatesByZone = `-- name: GetShippingRatesByZone :many
SELECT sr.id, sr.shipping_method_id, sr.shipping_zone_id, sr.name, sr.base_rate, sr.min_order_amount, sr.max_order_amount, sr.free_shipping_threshold, sr.is_active, sr.created_at, sr.updated_at, sm.name as method_name
FROM shipping_rates sr
JOIN shipping_methods sm ON sr.shipping_method_id = sm.id
WHERE sr.shipping_zone_id = $1 AND sr.is_active = TRUE
ORDER BY sr.base_rate
`

type GetShippingRatesByZoneRow struct {
	ID                    uuid.UUID      `json:"id"`
	ShippingMethodID      uuid.UUID      `json:"shippingMethodId"`
	ShippingZoneID        uuid.UUID      `json:"shippingZoneId"`
	Name                  string         `json:"name"`
	BaseRate              pgtype.Numeric `json:"baseRate"`
	MinOrderAmount        pgtype.Numeric `json:"minOrderAmount"`
	MaxOrderAmount        pgtype.Numeric `json:"maxOrderAmount"`
	FreeShippingThreshold pgtype.Numeric `json:"freeShippingThreshold"`
	IsActive              bool           `json:"isActive"`
	CreatedAt             time.Time      `json:"createdAt"`
	UpdatedAt             time.Time      `json:"updatedAt"`
	MethodName            string         `json:"methodName"`
}

func (q *Queries) GetShippingRatesByZone(ctx context.Context, shippingZoneID uuid.UUID) ([]GetShippingRatesByZoneRow, error) {
	rows, err := q.db.Query(ctx, getShippingRatesByZone, shippingZoneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShippingRatesByZoneRow{}
	for rows.Next() {
		var i GetShippingRatesByZoneRow
		if err := rows.Scan(
			&i.ID,
			&i.ShippingMethodID,
			&i.ShippingZoneID,
			&i.Name,
			&i.BaseRate,
			&i.MinOrderAmount,
			&i.MaxOrderAmount,
			&i.FreeShippingThreshold,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MethodName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShippingZoneByID = `-- name: GetShippingZoneByID :one
SELECT id, name, description, countries, states, zip_codes, is_active, created_at, updated_at FROM shipping_zones WHERE id = $1
`

func (q *Queries) GetShippingZoneByID(ctx context.Context, id uuid.UUID) (ShippingZone, error) {
	row := q.db.QueryRow(ctx, getShippingZoneByID, id)
	var i ShippingZone
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Countries,
		&i.States,
		&i.ZipCodes,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShippingZones = `-- name: GetShippingZones :many
SELECT id, name, description, countries, states, zip_codes, is_active, created_at, updated_at FROM shipping_zones WHERE is_active = COALESCE($1, TRUE) ORDER BY name
`

func (q *Queries) GetShippingZones(ctx context.Context, isActive *bool) ([]ShippingZone, error) {
	rows, err := q.db.Query(ctx, getShippingZones, isActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShippingZone{}
	for rows.Next() {
		var i ShippingZone
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Countries,
			&i.States,
			&i.ZipCodes,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type SeedShippingMethodsParams struct {
	Name                  string  `json:"name"`
	Description           *string `json:"description"`
	IsActive              bool    `json:"isActive"`
	RequiresAddress       bool    `json:"requiresAddress"`
	EstimatedDeliveryTime *string `json:"estimatedDeliveryTime"`
}

type SeedShippingZonesParams struct {
	Name        string   `json:"name"`
	Description *string  `json:"description"`
	Countries   []string `json:"countries"`
	States      []string `json:"states"`
	ZipCodes    []string `json:"zipCodes"`
	IsActive    bool     `json:"isActive"`
}

const updateShippingMethod = `-- name: UpdateShippingMethod :one
UPDATE shipping_methods SET
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    is_active = COALESCE($4, is_active),
    requires_address = COALESCE($5, requires_address),
    estimated_delivery_time = COALESCE($6, estimated_delivery_time),
    icon_url = COALESCE($7, icon_url),
    updated_at = NOW()
WHERE id = $1 RETURNING id, name, description, is_active, requires_address, estimated_delivery_time, icon_url, created_at, updated_at
`

type UpdateShippingMethodParams struct {
	ID                    uuid.UUID `json:"id"`
	Name                  *string   `json:"name"`
	Description           *string   `json:"description"`
	IsActive              *bool     `json:"isActive"`
	RequiresAddress       *bool     `json:"requiresAddress"`
	EstimatedDeliveryTime *string   `json:"estimatedDeliveryTime"`
	IconUrl               *string   `json:"iconUrl"`
}

func (q *Queries) UpdateShippingMethod(ctx context.Context, arg UpdateShippingMethodParams) (ShippingMethod, error) {
	row := q.db.QueryRow(ctx, updateShippingMethod,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.IsActive,
		arg.RequiresAddress,
		arg.EstimatedDeliveryTime,
		arg.IconUrl,
	)
	var i ShippingMethod
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.RequiresAddress,
		&i.EstimatedDeliveryTime,
		&i.IconUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateShippingRate = `-- name: UpdateShippingRate :one
UPDATE shipping_rates SET
    name = COALESCE($2, name),
    base_rate = COALESCE($3, base_rate),
    min_order_amount = COALESCE($4, min_order_amount),
    max_order_amount = COALESCE($5, max_order_amount),
    free_shipping_threshold = COALESCE($6, free_shipping_threshold),
    is_active = COALESCE($7, is_active),
    updated_at = NOW()
WHERE id = $1 RETURNING id, shipping_method_id, shipping_zone_id, name, base_rate, min_order_amount, max_order_amount, free_shipping_threshold, is_active, created_at, updated_at
`

type UpdateShippingRateParams struct {
	ID                    uuid.UUID      `json:"id"`
	Name                  *string        `json:"name"`
	BaseRate              pgtype.Numeric `json:"baseRate"`
	MinOrderAmount        pgtype.Numeric `json:"minOrderAmount"`
	MaxOrderAmount        pgtype.Numeric `json:"maxOrderAmount"`
	FreeShippingThreshold pgtype.Numeric `json:"freeShippingThreshold"`
	IsActive              *bool          `json:"isActive"`
}

func (q *Queries) UpdateShippingRate(ctx context.Context, arg UpdateShippingRateParams) (ShippingRate, error) {
	row := q.db.QueryRow(ctx, updateShippingRate,
		arg.ID,
		arg.Name,
		arg.BaseRate,
		arg.MinOrderAmount,
		arg.MaxOrderAmount,
		arg.FreeShippingThreshold,
		arg.IsActive,
	)
	var i ShippingRate
	err := row.Scan(
		&i.ID,
		&i.ShippingMethodID,
		&i.ShippingZoneID,
		&i.Name,
		&i.BaseRate,
		&i.MinOrderAmount,
		&i.MaxOrderAmount,
		&i.FreeShippingThreshold,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateShippingZone = `-- name: UpdateShippingZone :one
UPDATE shipping_zones SET
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    countries = COALESCE($4, countries),
    states = COALESCE($5, states),
    zip_codes = COALESCE($6, zip_codes),
    is_active = COALESCE($7, is_active),
    updated_at = NOW()
WHERE id = $1 RETURNING id, name, description, countries, states, zip_codes, is_active, created_at, updated_at
`

type UpdateShippingZoneParams struct {
	ID          uuid.UUID `json:"id"`
	Name        *string   `json:"name"`
	Description *string   `json:"description"`
	Countries   []string  `json:"countries"`
	States      []string  `json:"states"`
	ZipCodes    []string  `json:"zipCodes"`
	IsActive    *bool     `json:"isActive"`
}

func (q *Queries) UpdateShippingZone(ctx context.Context, arg UpdateShippingZoneParams) (ShippingZone, error) {
	row := q.db.QueryRow(ctx, updateShippingZone,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Countries,
		arg.States,
		arg.ZipCodes,
		arg.IsActive,
	)
	var i ShippingZone
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Countries,
		&i.States,
		&i.ZipCodes,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
