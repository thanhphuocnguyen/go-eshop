// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: rating.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countProductRatings = `-- name: CountProductRatings :one
SELECT COUNT(*) FROM product_ratings WHERE product_id = COALESCE($1, product_id) AND is_visible = TRUE
`

func (q *Queries) CountProductRatings(ctx context.Context, productID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProductRatings, productID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteProductRating = `-- name: DeleteProductRating :exec
DELETE FROM product_ratings WHERE id = $1
`

func (q *Queries) DeleteProductRating(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductRating, id)
	return err
}

const deleteRatingReplies = `-- name: DeleteRatingReplies :exec
DELETE FROM rating_replies WHERE id = $1
`

func (q *Queries) DeleteRatingReplies(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRatingReplies, id)
	return err
}

const deleteRatingVotes = `-- name: DeleteRatingVotes :exec
DELETE FROM rating_votes WHERE id = $1
`

func (q *Queries) DeleteRatingVotes(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRatingVotes, id)
	return err
}

const getProductRating = `-- name: GetProductRating :one
SELECT id, product_id, user_id, order_item_id, rating, review_title, review_content, verified_purchase, is_visible, is_approved, helpful_votes, unhelpful_votes, created_at, updated_at FROM product_ratings WHERE id = $1
`

func (q *Queries) GetProductRating(ctx context.Context, id uuid.UUID) (ProductRating, error) {
	row := q.db.QueryRow(ctx, getProductRating, id)
	var i ProductRating
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.OrderItemID,
		&i.Rating,
		&i.ReviewTitle,
		&i.ReviewContent,
		&i.VerifiedPurchase,
		&i.IsVisible,
		&i.IsApproved,
		&i.HelpfulVotes,
		&i.UnhelpfulVotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductRatings = `-- name: GetProductRatings :many
SELECT pr.id, pr.product_id, pr.user_id, pr.order_item_id, pr.rating, pr.review_title, pr.review_content, pr.verified_purchase, pr.is_visible, pr.is_approved, pr.helpful_votes, pr.unhelpful_votes, pr.created_at, pr.updated_at, pr.fullname, pr.email, pr.product_name, ia.id AS image_id, img.url as image_url, ia.role as image_role FROM
    (SELECT  r.id, r.product_id, r.user_id, r.order_item_id, r.rating, r.review_title, r.review_content, r.verified_purchase, r.is_visible, r.is_approved, r.helpful_votes, r.unhelpful_votes, r.created_at, r.updated_at, u.fullname, u.email, p.name AS product_name
    FROM product_ratings AS r
    JOIN users AS u ON u.id = r.user_id
    JOIN products AS p ON p.id = r.product_id
    WHERE r.product_id = COALESCE($3, r.product_id) AND r.is_visible = COALESCE($4, TRUE) AND r.is_approved = COALESCE($5, r.is_approved)
    ORDER BY r.created_at DESC
    LIMIT $1 OFFSET $2) as pr
LEFT JOIN image_assignments AS ia ON ia.entity_id = pr.id AND ia.entity_type = 'product_rating'
LEFT JOIN images AS img ON img.id = ia.image_id
`

type GetProductRatingsParams struct {
	Limit      int64       `json:"limit"`
	Offset     int64       `json:"offset"`
	ProductID  pgtype.UUID `json:"product_id"`
	IsVisible  *bool       `json:"is_visible"`
	IsApproved *bool       `json:"is_approved"`
}

type GetProductRatingsRow struct {
	ID               uuid.UUID      `json:"id"`
	ProductID        uuid.UUID      `json:"product_id"`
	UserID           uuid.UUID      `json:"user_id"`
	OrderItemID      pgtype.UUID    `json:"order_item_id"`
	Rating           pgtype.Numeric `json:"rating"`
	ReviewTitle      *string        `json:"review_title"`
	ReviewContent    *string        `json:"review_content"`
	VerifiedPurchase bool           `json:"verified_purchase"`
	IsVisible        bool           `json:"is_visible"`
	IsApproved       bool           `json:"is_approved"`
	HelpfulVotes     int32          `json:"helpful_votes"`
	UnhelpfulVotes   int32          `json:"unhelpful_votes"`
	CreatedAt        time.Time      `json:"created_at"`
	UpdatedAt        time.Time      `json:"updated_at"`
	Fullname         string         `json:"fullname"`
	Email            string         `json:"email"`
	ProductName      string         `json:"product_name"`
	ImageID          pgtype.UUID    `json:"image_id"`
	ImageUrl         *string        `json:"image_url"`
	ImageRole        *string        `json:"image_role"`
}

func (q *Queries) GetProductRatings(ctx context.Context, arg GetProductRatingsParams) ([]GetProductRatingsRow, error) {
	rows, err := q.db.Query(ctx, getProductRatings,
		arg.Limit,
		arg.Offset,
		arg.ProductID,
		arg.IsVisible,
		arg.IsApproved,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductRatingsRow{}
	for rows.Next() {
		var i GetProductRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.UserID,
			&i.OrderItemID,
			&i.Rating,
			&i.ReviewTitle,
			&i.ReviewContent,
			&i.VerifiedPurchase,
			&i.IsVisible,
			&i.IsApproved,
			&i.HelpfulVotes,
			&i.UnhelpfulVotes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Fullname,
			&i.Email,
			&i.ProductName,
			&i.ImageID,
			&i.ImageUrl,
			&i.ImageRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductRatingsByOrderItemIDs = `-- name: GetProductRatingsByOrderItemIDs :many
SELECT 
    pr.id, pr.product_id, pr.user_id, pr.order_item_id, pr.rating, pr.review_title, pr.review_content, pr.verified_purchase, pr.is_visible, pr.is_approved, pr.helpful_votes, pr.unhelpful_votes, pr.created_at, pr.updated_at, 
    u.id AS user_id, u.fullname, u.email
FROM product_ratings AS pr
JOIN users AS u ON u.id = pr.user_id
WHERE pr.order_item_id = ANY($1::uuid[]) AND pr.is_visible = TRUE
ORDER BY pr.created_at DESC
`

type GetProductRatingsByOrderItemIDsRow struct {
	ProductRating ProductRating `json:"product_rating"`
	UserID        uuid.UUID     `json:"user_id"`
	Fullname      string        `json:"fullname"`
	Email         string        `json:"email"`
}

func (q *Queries) GetProductRatingsByOrderItemIDs(ctx context.Context, ids []uuid.UUID) ([]GetProductRatingsByOrderItemIDsRow, error) {
	rows, err := q.db.Query(ctx, getProductRatingsByOrderItemIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductRatingsByOrderItemIDsRow{}
	for rows.Next() {
		var i GetProductRatingsByOrderItemIDsRow
		if err := rows.Scan(
			&i.ProductRating.ID,
			&i.ProductRating.ProductID,
			&i.ProductRating.UserID,
			&i.ProductRating.OrderItemID,
			&i.ProductRating.Rating,
			&i.ProductRating.ReviewTitle,
			&i.ProductRating.ReviewContent,
			&i.ProductRating.VerifiedPurchase,
			&i.ProductRating.IsVisible,
			&i.ProductRating.IsApproved,
			&i.ProductRating.HelpfulVotes,
			&i.ProductRating.UnhelpfulVotes,
			&i.ProductRating.CreatedAt,
			&i.ProductRating.UpdatedAt,
			&i.UserID,
			&i.Fullname,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductRatingsByUserID = `-- name: GetProductRatingsByUserID :many
SELECT 
    pr.id, pr.product_id, pr.user_id, pr.order_item_id, pr.rating, pr.review_title, pr.review_content, pr.verified_purchase, pr.is_visible, pr.is_approved, pr.helpful_votes, pr.unhelpful_votes, pr.created_at, pr.updated_at, 
    u.id AS user_id, u.fullname, u.email
FROM product_ratings AS pr
JOIN users AS u ON u.id = pr.user_id
WHERE pr.user_id = $1 AND pr.is_visible = TRUE
ORDER BY pr.created_at DESC
LIMIT $2 OFFSET $3
`

type GetProductRatingsByUserIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int64     `json:"limit"`
	Offset int64     `json:"offset"`
}

type GetProductRatingsByUserIDRow struct {
	ProductRating ProductRating `json:"product_rating"`
	UserID        uuid.UUID     `json:"user_id"`
	Fullname      string        `json:"fullname"`
	Email         string        `json:"email"`
}

func (q *Queries) GetProductRatingsByUserID(ctx context.Context, arg GetProductRatingsByUserIDParams) ([]GetProductRatingsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getProductRatingsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductRatingsByUserIDRow{}
	for rows.Next() {
		var i GetProductRatingsByUserIDRow
		if err := rows.Scan(
			&i.ProductRating.ID,
			&i.ProductRating.ProductID,
			&i.ProductRating.UserID,
			&i.ProductRating.OrderItemID,
			&i.ProductRating.Rating,
			&i.ProductRating.ReviewTitle,
			&i.ProductRating.ReviewContent,
			&i.ProductRating.VerifiedPurchase,
			&i.ProductRating.IsVisible,
			&i.ProductRating.IsApproved,
			&i.ProductRating.HelpfulVotes,
			&i.ProductRating.UnhelpfulVotes,
			&i.ProductRating.CreatedAt,
			&i.ProductRating.UpdatedAt,
			&i.UserID,
			&i.Fullname,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductRatingsCount = `-- name: GetProductRatingsCount :one
SELECT COUNT(*) FROM product_ratings WHERE product_id = $1 AND is_visible = TRUE
`

func (q *Queries) GetProductRatingsCount(ctx context.Context, productID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getProductRatingsCount, productID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRatingReplies = `-- name: GetRatingReplies :one
SELECT id, rating_id, reply_by, content, is_visible, created_at, updated_at FROM rating_replies WHERE id = $1
`

func (q *Queries) GetRatingReplies(ctx context.Context, id uuid.UUID) (RatingReply, error) {
	row := q.db.QueryRow(ctx, getRatingReplies, id)
	var i RatingReply
	err := row.Scan(
		&i.ID,
		&i.RatingID,
		&i.ReplyBy,
		&i.Content,
		&i.IsVisible,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRatingRepliesByRatingID = `-- name: GetRatingRepliesByRatingID :many
SELECT 
    rr.id, rr.rating_id, rr.reply_by, rr.content, rr.is_visible, rr.created_at, rr.updated_at, 
    u.id AS reply_by, u.fullname, u.email
FROM rating_replies AS rr
JOIN users AS u ON u.id = rr.reply_by
WHERE rr.rating_id = $1
`

type GetRatingRepliesByRatingIDRow struct {
	RatingReply RatingReply `json:"rating_reply"`
	ReplyBy     uuid.UUID   `json:"reply_by"`
	Fullname    string      `json:"fullname"`
	Email       string      `json:"email"`
}

func (q *Queries) GetRatingRepliesByRatingID(ctx context.Context, ratingID uuid.UUID) ([]GetRatingRepliesByRatingIDRow, error) {
	rows, err := q.db.Query(ctx, getRatingRepliesByRatingID, ratingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRatingRepliesByRatingIDRow{}
	for rows.Next() {
		var i GetRatingRepliesByRatingIDRow
		if err := rows.Scan(
			&i.RatingReply.ID,
			&i.RatingReply.RatingID,
			&i.RatingReply.ReplyBy,
			&i.RatingReply.Content,
			&i.RatingReply.IsVisible,
			&i.RatingReply.CreatedAt,
			&i.RatingReply.UpdatedAt,
			&i.ReplyBy,
			&i.Fullname,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingRepliesByUserID = `-- name: GetRatingRepliesByUserID :many
SELECT 
    rr.id, rr.rating_id, rr.reply_by, rr.content, rr.is_visible, rr.created_at, rr.updated_at, 
    u.id AS reply_by, u.fullname, u.email
FROM rating_replies AS rr
JOIN users AS u ON u.id = rr.reply_by
WHERE rr.reply_by = $1
`

type GetRatingRepliesByUserIDRow struct {
	RatingReply RatingReply `json:"rating_reply"`
	ReplyBy     uuid.UUID   `json:"reply_by"`
	Fullname    string      `json:"fullname"`
	Email       string      `json:"email"`
}

func (q *Queries) GetRatingRepliesByUserID(ctx context.Context, replyBy uuid.UUID) ([]GetRatingRepliesByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getRatingRepliesByUserID, replyBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRatingRepliesByUserIDRow{}
	for rows.Next() {
		var i GetRatingRepliesByUserIDRow
		if err := rows.Scan(
			&i.RatingReply.ID,
			&i.RatingReply.RatingID,
			&i.RatingReply.ReplyBy,
			&i.RatingReply.Content,
			&i.RatingReply.IsVisible,
			&i.RatingReply.CreatedAt,
			&i.RatingReply.UpdatedAt,
			&i.ReplyBy,
			&i.Fullname,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingVote = `-- name: GetRatingVote :one
SELECT id, rating_id, user_id, is_helpful, created_at, updated_at FROM rating_votes WHERE rating_id = $1 AND user_id = $2
`

type GetRatingVoteParams struct {
	RatingID uuid.UUID `json:"rating_id"`
	UserID   uuid.UUID `json:"user_id"`
}

func (q *Queries) GetRatingVote(ctx context.Context, arg GetRatingVoteParams) (RatingVote, error) {
	row := q.db.QueryRow(ctx, getRatingVote, arg.RatingID, arg.UserID)
	var i RatingVote
	err := row.Scan(
		&i.ID,
		&i.RatingID,
		&i.UserID,
		&i.IsHelpful,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRatingVotes = `-- name: GetRatingVotes :one
SELECT id, rating_id, user_id, is_helpful, created_at, updated_at FROM rating_votes WHERE id = $1
`

func (q *Queries) GetRatingVotes(ctx context.Context, id uuid.UUID) (RatingVote, error) {
	row := q.db.QueryRow(ctx, getRatingVotes, id)
	var i RatingVote
	err := row.Scan(
		&i.ID,
		&i.RatingID,
		&i.UserID,
		&i.IsHelpful,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRatingVotesByRatingID = `-- name: GetRatingVotesByRatingID :many
SELECT id, rating_id, user_id, is_helpful, created_at, updated_at FROM rating_votes WHERE rating_id = $1
`

func (q *Queries) GetRatingVotesByRatingID(ctx context.Context, ratingID uuid.UUID) ([]RatingVote, error) {
	rows, err := q.db.Query(ctx, getRatingVotesByRatingID, ratingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RatingVote{}
	for rows.Next() {
		var i RatingVote
		if err := rows.Scan(
			&i.ID,
			&i.RatingID,
			&i.UserID,
			&i.IsHelpful,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingVotesByUserID = `-- name: GetRatingVotesByUserID :many
SELECT id, rating_id, user_id, is_helpful, created_at, updated_at FROM rating_votes WHERE user_id = $1
`

func (q *Queries) GetRatingVotesByUserID(ctx context.Context, userID uuid.UUID) ([]RatingVote, error) {
	rows, err := q.db.Query(ctx, getRatingVotesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RatingVote{}
	for rows.Next() {
		var i RatingVote
		if err := rows.Scan(
			&i.ID,
			&i.RatingID,
			&i.UserID,
			&i.IsHelpful,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingVotesCount = `-- name: GetRatingVotesCount :one
SELECT COUNT(*) FROM rating_votes WHERE rating_id = $1 AND is_helpful = TRUE
`

func (q *Queries) GetRatingVotesCount(ctx context.Context, ratingID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getRatingVotesCount, ratingID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRatingVotesCountByUserID = `-- name: GetRatingVotesCountByUserID :one
SELECT COUNT(*) FROM rating_votes WHERE user_id = $1 AND is_helpful = TRUE
`

func (q *Queries) GetRatingVotesCountByUserID(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getRatingVotesCountByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertProductRating = `-- name: InsertProductRating :one
INSERT INTO product_ratings (product_id, user_id, order_item_id, rating, review_title, review_content, verified_purchase) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, product_id, user_id, order_item_id, rating, review_title, review_content, verified_purchase, is_visible, is_approved, helpful_votes, unhelpful_votes, created_at, updated_at
`

type InsertProductRatingParams struct {
	ProductID        uuid.UUID      `json:"product_id"`
	UserID           uuid.UUID      `json:"user_id"`
	OrderItemID      pgtype.UUID    `json:"order_item_id"`
	Rating           pgtype.Numeric `json:"rating"`
	ReviewTitle      *string        `json:"review_title"`
	ReviewContent    *string        `json:"review_content"`
	VerifiedPurchase bool           `json:"verified_purchase"`
}

func (q *Queries) InsertProductRating(ctx context.Context, arg InsertProductRatingParams) (ProductRating, error) {
	row := q.db.QueryRow(ctx, insertProductRating,
		arg.ProductID,
		arg.UserID,
		arg.OrderItemID,
		arg.Rating,
		arg.ReviewTitle,
		arg.ReviewContent,
		arg.VerifiedPurchase,
	)
	var i ProductRating
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.OrderItemID,
		&i.Rating,
		&i.ReviewTitle,
		&i.ReviewContent,
		&i.VerifiedPurchase,
		&i.IsVisible,
		&i.IsApproved,
		&i.HelpfulVotes,
		&i.UnhelpfulVotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertRatingReply = `-- name: InsertRatingReply :one
INSERT INTO rating_replies (rating_id, reply_by, content) VALUES ($1, $2, $3) RETURNING id, rating_id, reply_by, content, is_visible, created_at, updated_at
`

type InsertRatingReplyParams struct {
	RatingID uuid.UUID `json:"rating_id"`
	ReplyBy  uuid.UUID `json:"reply_by"`
	Content  string    `json:"content"`
}

func (q *Queries) InsertRatingReply(ctx context.Context, arg InsertRatingReplyParams) (RatingReply, error) {
	row := q.db.QueryRow(ctx, insertRatingReply, arg.RatingID, arg.ReplyBy, arg.Content)
	var i RatingReply
	err := row.Scan(
		&i.ID,
		&i.RatingID,
		&i.ReplyBy,
		&i.Content,
		&i.IsVisible,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertRatingVotes = `-- name: InsertRatingVotes :one
INSERT INTO rating_votes (rating_id, user_id, is_helpful) VALUES ($1, $2, $3) RETURNING id, rating_id, user_id, is_helpful, created_at, updated_at
`

type InsertRatingVotesParams struct {
	RatingID  uuid.UUID `json:"rating_id"`
	UserID    uuid.UUID `json:"user_id"`
	IsHelpful bool      `json:"is_helpful"`
}

func (q *Queries) InsertRatingVotes(ctx context.Context, arg InsertRatingVotesParams) (RatingVote, error) {
	row := q.db.QueryRow(ctx, insertRatingVotes, arg.RatingID, arg.UserID, arg.IsHelpful)
	var i RatingVote
	err := row.Scan(
		&i.ID,
		&i.RatingID,
		&i.UserID,
		&i.IsHelpful,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductRating = `-- name: UpdateProductRating :one
UPDATE product_ratings SET 
    rating = COALESCE($2, rating), 
    review_title = COALESCE($3, review_title), 
    review_content = COALESCE($4, review_content), 
    is_visible = COALESCE($5, is_visible), 
    is_approved = COALESCE($6, is_approved),
    verified_purchase = COALESCE($7, verified_purchase),
    helpful_votes = COALESCE($8, helpful_votes),
    unhelpful_votes = COALESCE($9, unhelpful_votes),
    updated_at = NOW()
WHERE id = $1 RETURNING id, product_id, user_id, order_item_id, rating, review_title, review_content, verified_purchase, is_visible, is_approved, helpful_votes, unhelpful_votes, created_at, updated_at
`

type UpdateProductRatingParams struct {
	ID               uuid.UUID      `json:"id"`
	Rating           pgtype.Numeric `json:"rating"`
	ReviewTitle      *string        `json:"review_title"`
	ReviewContent    *string        `json:"review_content"`
	IsVisible        *bool          `json:"is_visible"`
	IsApproved       *bool          `json:"is_approved"`
	VerifiedPurchase *bool          `json:"verified_purchase"`
	HelpfulVotes     *int32         `json:"helpful_votes"`
	UnhelpfulVotes   *int32         `json:"unhelpful_votes"`
}

func (q *Queries) UpdateProductRating(ctx context.Context, arg UpdateProductRatingParams) (ProductRating, error) {
	row := q.db.QueryRow(ctx, updateProductRating,
		arg.ID,
		arg.Rating,
		arg.ReviewTitle,
		arg.ReviewContent,
		arg.IsVisible,
		arg.IsApproved,
		arg.VerifiedPurchase,
		arg.HelpfulVotes,
		arg.UnhelpfulVotes,
	)
	var i ProductRating
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.OrderItemID,
		&i.Rating,
		&i.ReviewTitle,
		&i.ReviewContent,
		&i.VerifiedPurchase,
		&i.IsVisible,
		&i.IsApproved,
		&i.HelpfulVotes,
		&i.UnhelpfulVotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRatingReplies = `-- name: UpdateRatingReplies :one
UPDATE rating_replies SET 
    content = COALESCE($2, content)
WHERE id = $1 RETURNING id, rating_id, reply_by, content, is_visible, created_at, updated_at
`

type UpdateRatingRepliesParams struct {
	ID           uuid.UUID `json:"id"`
	ReplyContent *string   `json:"reply_content"`
}

func (q *Queries) UpdateRatingReplies(ctx context.Context, arg UpdateRatingRepliesParams) (RatingReply, error) {
	row := q.db.QueryRow(ctx, updateRatingReplies, arg.ID, arg.ReplyContent)
	var i RatingReply
	err := row.Scan(
		&i.ID,
		&i.RatingID,
		&i.ReplyBy,
		&i.Content,
		&i.IsVisible,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRatingVote = `-- name: UpdateRatingVote :one
UPDATE rating_votes SET 
    is_helpful = COALESCE($2, is_helpful)
WHERE id = $1 RETURNING id, rating_id, user_id, is_helpful, created_at, updated_at
`

type UpdateRatingVoteParams struct {
	ID        uuid.UUID `json:"id"`
	IsHelpful *bool     `json:"is_helpful"`
}

func (q *Queries) UpdateRatingVote(ctx context.Context, arg UpdateRatingVoteParams) (RatingVote, error) {
	row := q.db.QueryRow(ctx, updateRatingVote, arg.ID, arg.IsHelpful)
	var i RatingVote
	err := row.Scan(
		&i.ID,
		&i.RatingID,
		&i.UserID,
		&i.IsHelpful,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
