// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: rating.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countProductRatings = `-- name: CountProductRatings :one
SELECT COUNT(*) FROM product_ratings WHERE product_id = $1 AND is_visible = TRUE
`

func (q *Queries) CountProductRatings(ctx context.Context, productID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProductRatings, productID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteProductRating = `-- name: DeleteProductRating :exec
DELETE FROM product_ratings WHERE id = $1
`

func (q *Queries) DeleteProductRating(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductRating, id)
	return err
}

const deleteRatingReplies = `-- name: DeleteRatingReplies :exec
DELETE FROM rating_replies WHERE id = $1
`

func (q *Queries) DeleteRatingReplies(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRatingReplies, id)
	return err
}

const deleteRatingVotes = `-- name: DeleteRatingVotes :exec
DELETE FROM rating_votes WHERE id = $1
`

func (q *Queries) DeleteRatingVotes(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRatingVotes, id)
	return err
}

const getProductRating = `-- name: GetProductRating :one
SELECT id, product_id, user_id, order_item_id, rating, review_title, review_content, verified_purchase, is_visible, is_approved, helpful_votes, unhelpful_votes, created_at, updated_at FROM product_ratings WHERE id = $1
`

func (q *Queries) GetProductRating(ctx context.Context, id uuid.UUID) (ProductRating, error) {
	row := q.db.QueryRow(ctx, getProductRating, id)
	var i ProductRating
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.OrderItemID,
		&i.Rating,
		&i.ReviewTitle,
		&i.ReviewContent,
		&i.VerifiedPurchase,
		&i.IsVisible,
		&i.IsApproved,
		&i.HelpfulVotes,
		&i.UnhelpfulVotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductRatings = `-- name: GetProductRatings :many
SELECT 
    pr.id, pr.product_id, pr.user_id, pr.order_item_id, pr.rating, pr.review_title, pr.review_content, pr.verified_purchase, pr.is_visible, pr.is_approved, pr.helpful_votes, pr.unhelpful_votes, pr.created_at, pr.updated_at, 
    u.id AS user_id, u.fullname, u.email
FROM product_ratings AS pr
JOIN users AS u ON u.id = pr.user_id
WHERE pr.product_id = $1 AND pr.is_visible = TRUE
ORDER BY pr.created_at DESC
LIMIT $2 OFFSET $3
`

type GetProductRatingsParams struct {
	ProductID uuid.UUID `json:"product_id"`
	Limit     int64     `json:"limit"`
	Offset    int64     `json:"offset"`
}

type GetProductRatingsRow struct {
	ProductRating ProductRating `json:"product_rating"`
	UserID        uuid.UUID     `json:"user_id"`
	Fullname      string        `json:"fullname"`
	Email         string        `json:"email"`
}

func (q *Queries) GetProductRatings(ctx context.Context, arg GetProductRatingsParams) ([]GetProductRatingsRow, error) {
	rows, err := q.db.Query(ctx, getProductRatings, arg.ProductID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductRatingsRow{}
	for rows.Next() {
		var i GetProductRatingsRow
		if err := rows.Scan(
			&i.ProductRating.ID,
			&i.ProductRating.ProductID,
			&i.ProductRating.UserID,
			&i.ProductRating.OrderItemID,
			&i.ProductRating.Rating,
			&i.ProductRating.ReviewTitle,
			&i.ProductRating.ReviewContent,
			&i.ProductRating.VerifiedPurchase,
			&i.ProductRating.IsVisible,
			&i.ProductRating.IsApproved,
			&i.ProductRating.HelpfulVotes,
			&i.ProductRating.UnhelpfulVotes,
			&i.ProductRating.CreatedAt,
			&i.ProductRating.UpdatedAt,
			&i.UserID,
			&i.Fullname,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductRatingsByUserID = `-- name: GetProductRatingsByUserID :many
SELECT 
    pr.id, pr.product_id, pr.user_id, pr.order_item_id, pr.rating, pr.review_title, pr.review_content, pr.verified_purchase, pr.is_visible, pr.is_approved, pr.helpful_votes, pr.unhelpful_votes, pr.created_at, pr.updated_at, 
    u.id AS user_id, u.fullname, u.email
FROM product_ratings AS pr
JOIN users AS u ON u.id = pr.user_id
WHERE pr.user_id = $1 AND pr.is_visible = TRUE
ORDER BY pr.created_at DESC
LIMIT $2 OFFSET $3
`

type GetProductRatingsByUserIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int64     `json:"limit"`
	Offset int64     `json:"offset"`
}

type GetProductRatingsByUserIDRow struct {
	ProductRating ProductRating `json:"product_rating"`
	UserID        uuid.UUID     `json:"user_id"`
	Fullname      string        `json:"fullname"`
	Email         string        `json:"email"`
}

func (q *Queries) GetProductRatingsByUserID(ctx context.Context, arg GetProductRatingsByUserIDParams) ([]GetProductRatingsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getProductRatingsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductRatingsByUserIDRow{}
	for rows.Next() {
		var i GetProductRatingsByUserIDRow
		if err := rows.Scan(
			&i.ProductRating.ID,
			&i.ProductRating.ProductID,
			&i.ProductRating.UserID,
			&i.ProductRating.OrderItemID,
			&i.ProductRating.Rating,
			&i.ProductRating.ReviewTitle,
			&i.ProductRating.ReviewContent,
			&i.ProductRating.VerifiedPurchase,
			&i.ProductRating.IsVisible,
			&i.ProductRating.IsApproved,
			&i.ProductRating.HelpfulVotes,
			&i.ProductRating.UnhelpfulVotes,
			&i.ProductRating.CreatedAt,
			&i.ProductRating.UpdatedAt,
			&i.UserID,
			&i.Fullname,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductRatingsCount = `-- name: GetProductRatingsCount :one
SELECT COUNT(*) FROM product_ratings WHERE product_id = $1 AND is_visible = TRUE
`

func (q *Queries) GetProductRatingsCount(ctx context.Context, productID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getProductRatingsCount, productID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRatingReplies = `-- name: GetRatingReplies :one
SELECT id, rating_id, reply_by, content, is_visible, created_at, updated_at FROM rating_replies WHERE id = $1
`

func (q *Queries) GetRatingReplies(ctx context.Context, id uuid.UUID) (RatingReply, error) {
	row := q.db.QueryRow(ctx, getRatingReplies, id)
	var i RatingReply
	err := row.Scan(
		&i.ID,
		&i.RatingID,
		&i.ReplyBy,
		&i.Content,
		&i.IsVisible,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRatingRepliesByRatingID = `-- name: GetRatingRepliesByRatingID :many
SELECT 
    rr.id, rr.rating_id, rr.reply_by, rr.content, rr.is_visible, rr.created_at, rr.updated_at, 
    u.id AS reply_by, u.fullname, u.email
FROM rating_replies AS rr
JOIN users AS u ON u.id = rr.reply_by
WHERE rr.rating_id = $1
`

type GetRatingRepliesByRatingIDRow struct {
	RatingReply RatingReply `json:"rating_reply"`
	ReplyBy     uuid.UUID   `json:"reply_by"`
	Fullname    string      `json:"fullname"`
	Email       string      `json:"email"`
}

func (q *Queries) GetRatingRepliesByRatingID(ctx context.Context, ratingID uuid.UUID) ([]GetRatingRepliesByRatingIDRow, error) {
	rows, err := q.db.Query(ctx, getRatingRepliesByRatingID, ratingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRatingRepliesByRatingIDRow{}
	for rows.Next() {
		var i GetRatingRepliesByRatingIDRow
		if err := rows.Scan(
			&i.RatingReply.ID,
			&i.RatingReply.RatingID,
			&i.RatingReply.ReplyBy,
			&i.RatingReply.Content,
			&i.RatingReply.IsVisible,
			&i.RatingReply.CreatedAt,
			&i.RatingReply.UpdatedAt,
			&i.ReplyBy,
			&i.Fullname,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingRepliesByUserID = `-- name: GetRatingRepliesByUserID :many
SELECT 
    rr.id, rr.rating_id, rr.reply_by, rr.content, rr.is_visible, rr.created_at, rr.updated_at, 
    u.id AS reply_by, u.fullname, u.email
FROM rating_replies AS rr
JOIN users AS u ON u.id = rr.reply_by
WHERE rr.reply_by = $1
`

type GetRatingRepliesByUserIDRow struct {
	RatingReply RatingReply `json:"rating_reply"`
	ReplyBy     uuid.UUID   `json:"reply_by"`
	Fullname    string      `json:"fullname"`
	Email       string      `json:"email"`
}

func (q *Queries) GetRatingRepliesByUserID(ctx context.Context, replyBy uuid.UUID) ([]GetRatingRepliesByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getRatingRepliesByUserID, replyBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRatingRepliesByUserIDRow{}
	for rows.Next() {
		var i GetRatingRepliesByUserIDRow
		if err := rows.Scan(
			&i.RatingReply.ID,
			&i.RatingReply.RatingID,
			&i.RatingReply.ReplyBy,
			&i.RatingReply.Content,
			&i.RatingReply.IsVisible,
			&i.RatingReply.CreatedAt,
			&i.RatingReply.UpdatedAt,
			&i.ReplyBy,
			&i.Fullname,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingVotes = `-- name: GetRatingVotes :one
SELECT id, rating_id, user_id, is_helpful, created_at, updated_at FROM rating_votes WHERE id = $1
`

func (q *Queries) GetRatingVotes(ctx context.Context, id int32) (RatingVote, error) {
	row := q.db.QueryRow(ctx, getRatingVotes, id)
	var i RatingVote
	err := row.Scan(
		&i.ID,
		&i.RatingID,
		&i.UserID,
		&i.IsHelpful,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRatingVotesByRatingID = `-- name: GetRatingVotesByRatingID :many
SELECT id, rating_id, user_id, is_helpful, created_at, updated_at FROM rating_votes WHERE rating_id = $1
`

func (q *Queries) GetRatingVotesByRatingID(ctx context.Context, ratingID uuid.UUID) ([]RatingVote, error) {
	rows, err := q.db.Query(ctx, getRatingVotesByRatingID, ratingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RatingVote{}
	for rows.Next() {
		var i RatingVote
		if err := rows.Scan(
			&i.ID,
			&i.RatingID,
			&i.UserID,
			&i.IsHelpful,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingVotesByUserID = `-- name: GetRatingVotesByUserID :many
SELECT id, rating_id, user_id, is_helpful, created_at, updated_at FROM rating_votes WHERE user_id = $1
`

func (q *Queries) GetRatingVotesByUserID(ctx context.Context, userID uuid.UUID) ([]RatingVote, error) {
	rows, err := q.db.Query(ctx, getRatingVotesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RatingVote{}
	for rows.Next() {
		var i RatingVote
		if err := rows.Scan(
			&i.ID,
			&i.RatingID,
			&i.UserID,
			&i.IsHelpful,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingVotesCount = `-- name: GetRatingVotesCount :one
SELECT COUNT(*) FROM rating_votes WHERE rating_id = $1 AND is_helpful = TRUE
`

func (q *Queries) GetRatingVotesCount(ctx context.Context, ratingID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getRatingVotesCount, ratingID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRatingVotesCountByUserID = `-- name: GetRatingVotesCountByUserID :one
SELECT COUNT(*) FROM rating_votes WHERE user_id = $1 AND is_helpful = TRUE
`

func (q *Queries) GetRatingVotesCountByUserID(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getRatingVotesCountByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertProductRating = `-- name: InsertProductRating :one
INSERT INTO product_ratings (id,product_id,user_id,order_item_id,rating,review_title,review_content,verified_purchase) VALUES ($1, $2, $3, $4, $5,$6,$7,$8) RETURNING id, product_id, user_id, order_item_id, rating, review_title, review_content, verified_purchase, is_visible, is_approved, helpful_votes, unhelpful_votes, created_at, updated_at
`

type InsertProductRatingParams struct {
	ID               uuid.UUID      `json:"id"`
	ProductID        uuid.UUID      `json:"product_id"`
	UserID           uuid.UUID      `json:"user_id"`
	OrderItemID      pgtype.UUID    `json:"order_item_id"`
	Rating           pgtype.Numeric `json:"rating"`
	ReviewTitle      *string        `json:"review_title"`
	ReviewContent    *string        `json:"review_content"`
	VerifiedPurchase bool           `json:"verified_purchase"`
}

func (q *Queries) InsertProductRating(ctx context.Context, arg InsertProductRatingParams) (ProductRating, error) {
	row := q.db.QueryRow(ctx, insertProductRating,
		arg.ID,
		arg.ProductID,
		arg.UserID,
		arg.OrderItemID,
		arg.Rating,
		arg.ReviewTitle,
		arg.ReviewContent,
		arg.VerifiedPurchase,
	)
	var i ProductRating
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.OrderItemID,
		&i.Rating,
		&i.ReviewTitle,
		&i.ReviewContent,
		&i.VerifiedPurchase,
		&i.IsVisible,
		&i.IsApproved,
		&i.HelpfulVotes,
		&i.UnhelpfulVotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertRatingReply = `-- name: InsertRatingReply :one
INSERT INTO rating_replies (id, rating_id, reply_by, content) VALUES ($1, $2, $3, $4) RETURNING id, rating_id, reply_by, content, is_visible, created_at, updated_at
`

type InsertRatingReplyParams struct {
	ID       uuid.UUID `json:"id"`
	RatingID uuid.UUID `json:"rating_id"`
	ReplyBy  uuid.UUID `json:"reply_by"`
	Content  string    `json:"content"`
}

func (q *Queries) InsertRatingReply(ctx context.Context, arg InsertRatingReplyParams) (RatingReply, error) {
	row := q.db.QueryRow(ctx, insertRatingReply,
		arg.ID,
		arg.RatingID,
		arg.ReplyBy,
		arg.Content,
	)
	var i RatingReply
	err := row.Scan(
		&i.ID,
		&i.RatingID,
		&i.ReplyBy,
		&i.Content,
		&i.IsVisible,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertRatingVotes = `-- name: InsertRatingVotes :one
INSERT INTO rating_votes (rating_id, user_id, is_helpful) VALUES ($1, $2, $3) RETURNING id, rating_id, user_id, is_helpful, created_at, updated_at
`

type InsertRatingVotesParams struct {
	RatingID  uuid.UUID `json:"rating_id"`
	UserID    uuid.UUID `json:"user_id"`
	IsHelpful bool      `json:"is_helpful"`
}

func (q *Queries) InsertRatingVotes(ctx context.Context, arg InsertRatingVotesParams) (RatingVote, error) {
	row := q.db.QueryRow(ctx, insertRatingVotes, arg.RatingID, arg.UserID, arg.IsHelpful)
	var i RatingVote
	err := row.Scan(
		&i.ID,
		&i.RatingID,
		&i.UserID,
		&i.IsHelpful,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductRating = `-- name: UpdateProductRating :one
UPDATE product_ratings SET 
    rating = COALESCE($2, rating), 
    review_title = COALESCE($3, review_title), 
    review_content = COALESCE($4, review_content), 
    is_visible = COALESCE($5, is_visible), 
    is_approved = COALESCE($6, is_approved),
    verified_purchase = COALESCE($7, verified_purchase),
    helpful_votes = COALESCE($8, helpful_votes),
    unhelpful_votes = COALESCE($9, unhelpful_votes),
    updated_at = NOW()
WHERE id = $1 RETURNING id, product_id, user_id, order_item_id, rating, review_title, review_content, verified_purchase, is_visible, is_approved, helpful_votes, unhelpful_votes, created_at, updated_at
`

type UpdateProductRatingParams struct {
	ID               uuid.UUID      `json:"id"`
	Rating           pgtype.Numeric `json:"rating"`
	ReviewTitle      *string        `json:"review_title"`
	ReviewContent    *string        `json:"review_content"`
	IsVisible        *bool          `json:"is_visible"`
	IsApproved       *bool          `json:"is_approved"`
	VerifiedPurchase *bool          `json:"verified_purchase"`
	HelpfulVotes     *int32         `json:"helpful_votes"`
	UnhelpfulVotes   *int32         `json:"unhelpful_votes"`
}

func (q *Queries) UpdateProductRating(ctx context.Context, arg UpdateProductRatingParams) (ProductRating, error) {
	row := q.db.QueryRow(ctx, updateProductRating,
		arg.ID,
		arg.Rating,
		arg.ReviewTitle,
		arg.ReviewContent,
		arg.IsVisible,
		arg.IsApproved,
		arg.VerifiedPurchase,
		arg.HelpfulVotes,
		arg.UnhelpfulVotes,
	)
	var i ProductRating
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.OrderItemID,
		&i.Rating,
		&i.ReviewTitle,
		&i.ReviewContent,
		&i.VerifiedPurchase,
		&i.IsVisible,
		&i.IsApproved,
		&i.HelpfulVotes,
		&i.UnhelpfulVotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRatingReplies = `-- name: UpdateRatingReplies :one
UPDATE rating_replies SET 
    content = COALESCE($2, content)
WHERE id = $1 RETURNING id, rating_id, reply_by, content, is_visible, created_at, updated_at
`

type UpdateRatingRepliesParams struct {
	ID           uuid.UUID `json:"id"`
	ReplyContent *string   `json:"reply_content"`
}

func (q *Queries) UpdateRatingReplies(ctx context.Context, arg UpdateRatingRepliesParams) (RatingReply, error) {
	row := q.db.QueryRow(ctx, updateRatingReplies, arg.ID, arg.ReplyContent)
	var i RatingReply
	err := row.Scan(
		&i.ID,
		&i.RatingID,
		&i.ReplyBy,
		&i.Content,
		&i.IsVisible,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRatingVotes = `-- name: UpdateRatingVotes :one
UPDATE rating_votes SET 
    is_helpful = COALESCE($2, is_helpful)
WHERE id = $1 RETURNING id, rating_id, user_id, is_helpful, created_at, updated_at
`

type UpdateRatingVotesParams struct {
	ID        int32 `json:"id"`
	IsHelpful *bool `json:"is_helpful"`
}

func (q *Queries) UpdateRatingVotes(ctx context.Context, arg UpdateRatingVotesParams) (RatingVote, error) {
	row := q.db.QueryRow(ctx, updateRatingVotes, arg.ID, arg.IsHelpful)
	var i RatingVote
	err := row.Scan(
		&i.ID,
		&i.RatingID,
		&i.UserID,
		&i.IsHelpful,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
