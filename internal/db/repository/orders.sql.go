// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countOrders = `-- name: CountOrders :one
SELECT
    COUNT(*)
FROM
    orders ord
LEFT JOIN payments p ON ord.id = p.order_id
WHERE
    ord.status = COALESCE($1, ord.status) AND
    customer_id = COALESCE($2, customer_id) AND
    p.status = COALESCE($3, p.status) AND
    ord.created_at >= COALESCE($4, ord.created_at) AND
    ord.created_at <= COALESCE($5, ord.created_at)
`

type CountOrdersParams struct {
	Status        interface{}        `json:"status"`
	CustomerID    pgtype.UUID        `json:"customerId"`
	PaymentStatus interface{}        `json:"paymentStatus"`
	StartDate     pgtype.Timestamptz `json:"startDate"`
	EndDate       pgtype.Timestamptz `json:"endDate"`
}

func (q *Queries) CountOrders(ctx context.Context, arg CountOrdersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders,
		arg.Status,
		arg.CustomerID,
		arg.PaymentStatus,
		arg.StartDate,
		arg.EndDate,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

type CreateBulkOrderItemsParams struct {
	OrderID              uuid.UUID               `json:"orderId"`
	VariantID            uuid.UUID               `json:"variantId"`
	Quantity             int16                   `json:"quantity"`
	PricePerUnitSnapshot pgtype.Numeric          `json:"pricePerUnitSnapshot"`
	VariantSkuSnapshot   string                  `json:"variantSkuSnapshot"`
	ProductNameSnapshot  string                  `json:"productNameSnapshot"`
	LineTotalSnapshot    pgtype.Numeric          `json:"lineTotalSnapshot"`
	AttributesSnapshot   []AttributeDataSnapshot `json:"attributesSnapshot"`
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    customer_id,
    customer_email,
    customer_name,
    customer_phone,
    total_price,
    shipping_address
)
VALUES 
    ($1, $2, $3, $4,  $5, $6)
RETURNING id, customer_id, customer_email, customer_name, customer_phone, shipping_address, total_price, status, confirmed_at, delivered_at, cancelled_at, shipping_method, refunded_at, order_date, updated_at, created_at, shipping_method_id, shipping_rate_id, estimated_delivery_date, tracking_url, shipping_provider, shipping_notes
`

type CreateOrderParams struct {
	CustomerID      uuid.UUID               `json:"customerId"`
	CustomerEmail   string                  `json:"customerEmail"`
	CustomerName    string                  `json:"customerName"`
	CustomerPhone   string                  `json:"customerPhone"`
	TotalPrice      pgtype.Numeric          `json:"totalPrice"`
	ShippingAddress ShippingAddressSnapshot `json:"shippingAddress"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.CustomerID,
		arg.CustomerEmail,
		arg.CustomerName,
		arg.CustomerPhone,
		arg.TotalPrice,
		arg.ShippingAddress,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.ShippingAddress,
		&i.TotalPrice,
		&i.Status,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.ShippingMethod,
		&i.RefundedAt,
		&i.OrderDate,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.ShippingMethodID,
		&i.ShippingRateID,
		&i.EstimatedDeliveryDate,
		&i.TrackingUrl,
		&i.ShippingProvider,
		&i.ShippingNotes,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO
    order_items (order_id, variant_id, quantity, price_per_unit_snapshot, variant_sku_snapshot, product_name_snapshot, line_total_snapshot, attributes_snapshot)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, order_id, variant_id, quantity, price_per_unit_snapshot, line_total_snapshot, product_name_snapshot, variant_sku_snapshot, attributes_snapshot, created_at, updated_at, discounted_price
`

type CreateOrderItemParams struct {
	OrderID              uuid.UUID               `json:"orderId"`
	VariantID            uuid.UUID               `json:"variantId"`
	Quantity             int16                   `json:"quantity"`
	PricePerUnitSnapshot pgtype.Numeric          `json:"pricePerUnitSnapshot"`
	VariantSkuSnapshot   string                  `json:"variantSkuSnapshot"`
	ProductNameSnapshot  string                  `json:"productNameSnapshot"`
	LineTotalSnapshot    pgtype.Numeric          `json:"lineTotalSnapshot"`
	AttributesSnapshot   []AttributeDataSnapshot `json:"attributesSnapshot"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.VariantID,
		arg.Quantity,
		arg.PricePerUnitSnapshot,
		arg.VariantSkuSnapshot,
		arg.ProductNameSnapshot,
		arg.LineTotalSnapshot,
		arg.AttributesSnapshot,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.VariantID,
		&i.Quantity,
		&i.PricePerUnitSnapshot,
		&i.LineTotalSnapshot,
		&i.ProductNameSnapshot,
		&i.VariantSkuSnapshot,
		&i.AttributesSnapshot,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DiscountedPrice,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM
    orders
WHERE
    id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrder, id)
	return err
}

const getOrder = `-- name: GetOrder :one
SELECT
    orders.id, orders.customer_id, orders.customer_email, orders.customer_name, orders.customer_phone, orders.shipping_address, orders.total_price, orders.status, orders.confirmed_at, orders.delivered_at, orders.cancelled_at, orders.shipping_method, orders.refunded_at, orders.order_date, orders.updated_at, orders.created_at, orders.shipping_method_id, orders.shipping_rate_id, orders.estimated_delivery_date, orders.tracking_url, orders.shipping_provider, orders.shipping_notes,
    pm.id as payment_id,
    pm.status as payment_status,
    pm.amount as payment_amount,
    pm.method,
    pm.gateway,
    pm.payment_intent_id,
    pm.created_at as payment_created_at,
    d.code,
    od.discount_amount
FROM
    orders
JOIN payments pm ON orders.id = pm.order_id
LEFT JOIN order_discounts od ON orders.id = od.order_id
LEFT JOIN discounts d ON od.discount_id = d.id
WHERE
    orders.id = $1
LIMIT 1
`

type GetOrderRow struct {
	ID                    uuid.UUID               `json:"id"`
	CustomerID            uuid.UUID               `json:"customerId"`
	CustomerEmail         string                  `json:"customerEmail"`
	CustomerName          string                  `json:"customerName"`
	CustomerPhone         string                  `json:"customerPhone"`
	ShippingAddress       ShippingAddressSnapshot `json:"shippingAddress"`
	TotalPrice            pgtype.Numeric          `json:"totalPrice"`
	Status                OrderStatus             `json:"status"`
	ConfirmedAt           pgtype.Timestamptz      `json:"confirmedAt"`
	DeliveredAt           pgtype.Timestamptz      `json:"deliveredAt"`
	CancelledAt           pgtype.Timestamptz      `json:"cancelledAt"`
	ShippingMethod        *string                 `json:"shippingMethod"`
	RefundedAt            pgtype.Timestamptz      `json:"refundedAt"`
	OrderDate             time.Time               `json:"orderDate"`
	UpdatedAt             time.Time               `json:"updatedAt"`
	CreatedAt             time.Time               `json:"createdAt"`
	ShippingMethodID      pgtype.UUID             `json:"shippingMethodId"`
	ShippingRateID        pgtype.UUID             `json:"shippingRateId"`
	EstimatedDeliveryDate pgtype.Timestamptz      `json:"estimatedDeliveryDate"`
	TrackingUrl           *string                 `json:"trackingUrl"`
	ShippingProvider      *string                 `json:"shippingProvider"`
	ShippingNotes         *string                 `json:"shippingNotes"`
	PaymentID             uuid.UUID               `json:"paymentId"`
	PaymentStatus         PaymentStatus           `json:"paymentStatus"`
	PaymentAmount         pgtype.Numeric          `json:"paymentAmount"`
	Method                PaymentMethod           `json:"method"`
	Gateway               *string                 `json:"gateway"`
	PaymentIntentID       *string                 `json:"paymentIntentId"`
	PaymentCreatedAt      pgtype.Timestamptz      `json:"paymentCreatedAt"`
	Code                  *string                 `json:"code"`
	DiscountAmount        pgtype.Numeric          `json:"discountAmount"`
}

func (q *Queries) GetOrder(ctx context.Context, id uuid.UUID) (GetOrderRow, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i GetOrderRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.ShippingAddress,
		&i.TotalPrice,
		&i.Status,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.ShippingMethod,
		&i.RefundedAt,
		&i.OrderDate,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.ShippingMethodID,
		&i.ShippingRateID,
		&i.EstimatedDeliveryDate,
		&i.TrackingUrl,
		&i.ShippingProvider,
		&i.ShippingNotes,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.PaymentAmount,
		&i.Method,
		&i.Gateway,
		&i.PaymentIntentID,
		&i.PaymentCreatedAt,
		&i.Code,
		&i.DiscountAmount,
	)
	return i, err
}

const getOrderItemByID = `-- name: GetOrderItemByID :one
SELECT
    oi.id as order_item_id,
    o.id as order_id,
    p.id as product_id,
    pv.id as variant_id,
    o.customer_id
FROM
    order_items oi
JOIN
    product_variants pv ON oi.variant_id = pv.id
JOIN
    products p ON pv.product_id = p.id
JOIN
    orders o ON oi.order_id = o.id
WHERE
    oi.id = $1
LIMIT 1
`

type GetOrderItemByIDRow struct {
	OrderItemID uuid.UUID `json:"orderItemId"`
	OrderID     uuid.UUID `json:"orderId"`
	ProductID   uuid.UUID `json:"productId"`
	VariantID   uuid.UUID `json:"variantId"`
	CustomerID  uuid.UUID `json:"customerId"`
}

func (q *Queries) GetOrderItemByID(ctx context.Context, id uuid.UUID) (GetOrderItemByIDRow, error) {
	row := q.db.QueryRow(ctx, getOrderItemByID, id)
	var i GetOrderItemByIDRow
	err := row.Scan(
		&i.OrderItemID,
		&i.OrderID,
		&i.ProductID,
		&i.VariantID,
		&i.CustomerID,
	)
	return i, err
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT
    oi.id, oi.order_id, oi.variant_id, oi.quantity, oi.price_per_unit_snapshot, oi.line_total_snapshot, oi.product_name_snapshot, oi.variant_sku_snapshot, oi.attributes_snapshot, oi.created_at, oi.updated_at, oi.discounted_price,
    p.name as product_name, i.url as image_url,
    rv.id as rating_id, rv.rating, rv.review_title, rv.review_content, rv.created_at as rating_created_at
FROM
    order_items oi
JOIN
    product_variants pv ON oi.variant_id = pv.id
JOIN
    products p ON pv.product_id = p.id
LEFT JOIN image_assignments AS ia ON ia.entity_id = pv.id AND ia.entity_type = 'variant'
LEFT JOIN images AS i ON i.id = ia.image_id
LEFT JOIN product_ratings rv ON rv.order_item_id = oi.id
WHERE
    oi.order_id = $1
`

type GetOrderItemsRow struct {
	ID                   uuid.UUID               `json:"id"`
	OrderID              uuid.UUID               `json:"orderId"`
	VariantID            uuid.UUID               `json:"variantId"`
	Quantity             int16                   `json:"quantity"`
	PricePerUnitSnapshot pgtype.Numeric          `json:"pricePerUnitSnapshot"`
	LineTotalSnapshot    pgtype.Numeric          `json:"lineTotalSnapshot"`
	ProductNameSnapshot  string                  `json:"productNameSnapshot"`
	VariantSkuSnapshot   string                  `json:"variantSkuSnapshot"`
	AttributesSnapshot   []AttributeDataSnapshot `json:"attributesSnapshot"`
	CreatedAt            time.Time               `json:"createdAt"`
	UpdatedAt            time.Time               `json:"updatedAt"`
	DiscountedPrice      pgtype.Numeric          `json:"discountedPrice"`
	ProductName          string                  `json:"productName"`
	ImageUrl             *string                 `json:"imageUrl"`
	RatingID             pgtype.UUID             `json:"ratingId"`
	Rating               pgtype.Numeric          `json:"rating"`
	ReviewTitle          *string                 `json:"reviewTitle"`
	ReviewContent        *string                 `json:"reviewContent"`
	RatingCreatedAt      pgtype.Timestamptz      `json:"ratingCreatedAt"`
}

func (q *Queries) GetOrderItems(ctx context.Context, orderID uuid.UUID) ([]GetOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderItemsRow{}
	for rows.Next() {
		var i GetOrderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.VariantID,
			&i.Quantity,
			&i.PricePerUnitSnapshot,
			&i.LineTotalSnapshot,
			&i.ProductNameSnapshot,
			&i.VariantSkuSnapshot,
			&i.AttributesSnapshot,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DiscountedPrice,
			&i.ProductName,
			&i.ImageUrl,
			&i.RatingID,
			&i.Rating,
			&i.ReviewTitle,
			&i.ReviewContent,
			&i.RatingCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsByOrderID = `-- name: GetOrderItemsByOrderID :many
SELECT
    oi.id as order_item_id,
    o.id as order_id,
    p.id as product_id,
    pv.id as variant_id,
    o.customer_id
FROM
    order_items oi
JOIN
    product_variants pv ON oi.variant_id = pv.id
JOIN
    products p ON pv.product_id = p.id
JOIN
    orders o ON oi.order_id = o.id
WHERE
    oi.order_id = $1
ORDER BY
    oi.id
`

type GetOrderItemsByOrderIDRow struct {
	OrderItemID uuid.UUID `json:"orderItemId"`
	OrderID     uuid.UUID `json:"orderId"`
	ProductID   uuid.UUID `json:"productId"`
	VariantID   uuid.UUID `json:"variantId"`
	CustomerID  uuid.UUID `json:"customerId"`
}

func (q *Queries) GetOrderItemsByOrderID(ctx context.Context, orderID uuid.UUID) ([]GetOrderItemsByOrderIDRow, error) {
	rows, err := q.db.Query(ctx, getOrderItemsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderItemsByOrderIDRow{}
	for rows.Next() {
		var i GetOrderItemsByOrderIDRow
		if err := rows.Scan(
			&i.OrderItemID,
			&i.OrderID,
			&i.ProductID,
			&i.VariantID,
			&i.CustomerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrders = `-- name: GetOrders :many
SELECT
    ord.id, ord.customer_id, ord.customer_email, ord.customer_name, ord.customer_phone, ord.shipping_address, ord.total_price, ord.status, ord.confirmed_at, ord.delivered_at, ord.cancelled_at, ord.shipping_method, ord.refunded_at, ord.order_date, ord.updated_at, ord.created_at, ord.shipping_method_id, ord.shipping_rate_id, ord.estimated_delivery_date, ord.tracking_url, ord.shipping_provider, ord.shipping_notes, pm.status as payment_status, COUNT(oi.id) as total_items
FROM
    orders ord
LEFT JOIN order_items oi ON ord.id = oi.id
LEFT JOIN payments pm ON ord.id = pm.order_id
WHERE
    ord.customer_id = COALESCE($3, ord.customer_id) AND
    ord.status = COALESCE($4, ord.status) AND
    ord.created_at >= COALESCE($5, ord.created_at) AND
    ord.created_at <= COALESCE($6, ord.created_at) AND
    pm.status = COALESCE($7, pm.status)
GROUP BY ord.id, pm.status
ORDER BY
    ord.created_at DESC
LIMIT $1
OFFSET $2
`

type GetOrdersParams struct {
	Limit         int64              `json:"limit"`
	Offset        int64              `json:"offset"`
	CustomerID    pgtype.UUID        `json:"customerId"`
	Status        interface{}        `json:"status"`
	StartDate     pgtype.Timestamptz `json:"startDate"`
	EndDate       pgtype.Timestamptz `json:"endDate"`
	PaymentStatus interface{}        `json:"paymentStatus"`
}

type GetOrdersRow struct {
	ID                    uuid.UUID               `json:"id"`
	CustomerID            uuid.UUID               `json:"customerId"`
	CustomerEmail         string                  `json:"customerEmail"`
	CustomerName          string                  `json:"customerName"`
	CustomerPhone         string                  `json:"customerPhone"`
	ShippingAddress       ShippingAddressSnapshot `json:"shippingAddress"`
	TotalPrice            pgtype.Numeric          `json:"totalPrice"`
	Status                OrderStatus             `json:"status"`
	ConfirmedAt           pgtype.Timestamptz      `json:"confirmedAt"`
	DeliveredAt           pgtype.Timestamptz      `json:"deliveredAt"`
	CancelledAt           pgtype.Timestamptz      `json:"cancelledAt"`
	ShippingMethod        *string                 `json:"shippingMethod"`
	RefundedAt            pgtype.Timestamptz      `json:"refundedAt"`
	OrderDate             time.Time               `json:"orderDate"`
	UpdatedAt             time.Time               `json:"updatedAt"`
	CreatedAt             time.Time               `json:"createdAt"`
	ShippingMethodID      pgtype.UUID             `json:"shippingMethodId"`
	ShippingRateID        pgtype.UUID             `json:"shippingRateId"`
	EstimatedDeliveryDate pgtype.Timestamptz      `json:"estimatedDeliveryDate"`
	TrackingUrl           *string                 `json:"trackingUrl"`
	ShippingProvider      *string                 `json:"shippingProvider"`
	ShippingNotes         *string                 `json:"shippingNotes"`
	PaymentStatus         interface{}             `json:"paymentStatus"`
	TotalItems            int64                   `json:"totalItems"`
}

func (q *Queries) GetOrders(ctx context.Context, arg GetOrdersParams) ([]GetOrdersRow, error) {
	rows, err := q.db.Query(ctx, getOrders,
		arg.Limit,
		arg.Offset,
		arg.CustomerID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
		arg.PaymentStatus,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrdersRow{}
	for rows.Next() {
		var i GetOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.CustomerEmail,
			&i.CustomerName,
			&i.CustomerPhone,
			&i.ShippingAddress,
			&i.TotalPrice,
			&i.Status,
			&i.ConfirmedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.ShippingMethod,
			&i.RefundedAt,
			&i.OrderDate,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.ShippingMethodID,
			&i.ShippingRateID,
			&i.EstimatedDeliveryDate,
			&i.TrackingUrl,
			&i.ShippingProvider,
			&i.ShippingNotes,
			&i.PaymentStatus,
			&i.TotalItems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItems = `-- name: ListOrderItems :many
SELECT
    id, order_id, variant_id, quantity, price_per_unit_snapshot, line_total_snapshot, product_name_snapshot, variant_sku_snapshot, attributes_snapshot, created_at, updated_at, discounted_price
FROM
    order_items
WHERE
    order_id = $1
ORDER BY
    id
LIMIT $2
OFFSET $3
`

type ListOrderItemsParams struct {
	OrderID uuid.UUID `json:"orderId"`
	Limit   int64     `json:"limit"`
	Offset  int64     `json:"offset"`
}

func (q *Queries) ListOrderItems(ctx context.Context, arg ListOrderItemsParams) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, listOrderItems, arg.OrderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.VariantID,
			&i.Quantity,
			&i.PricePerUnitSnapshot,
			&i.LineTotalSnapshot,
			&i.ProductNameSnapshot,
			&i.VariantSkuSnapshot,
			&i.AttributesSnapshot,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DiscountedPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE
    orders
SET
    status = coalesce($1, status),
    confirmed_at = coalesce($2, confirmed_at),
    cancelled_at = coalesce($3, cancelled_at),
    delivered_at = coalesce($4, delivered_at),
    updated_at = now()
WHERE
    id = $5
RETURNING orders.id
`

type UpdateOrderParams struct {
	Status      interface{}        `json:"status"`
	ConfirmedAt pgtype.Timestamptz `json:"confirmedAt"`
	CancelledAt pgtype.Timestamptz `json:"cancelledAt"`
	DeliveredAt pgtype.Timestamptz `json:"deliveredAt"`
	ID          uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updateOrder,
		arg.Status,
		arg.ConfirmedAt,
		arg.CancelledAt,
		arg.DeliveredAt,
		arg.ID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
