// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: image.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteImageAssignments = `-- name: DeleteImageAssignments :exec
DELETE FROM image_assignments WHERE image_id = $1 AND entity_type = $2
`

type DeleteImageAssignmentsParams struct {
	ImageID    uuid.UUID `json:"image_id"`
	EntityType string    `json:"entity_type"`
}

func (q *Queries) DeleteImageAssignments(ctx context.Context, arg DeleteImageAssignmentsParams) error {
	_, err := q.db.Exec(ctx, deleteImageAssignments, arg.ImageID, arg.EntityType)
	return err
}

const deleteProductImage = `-- name: DeleteProductImage :exec
DELETE FROM images WHERE id = $1
`

func (q *Queries) DeleteProductImage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductImage, id)
	return err
}

const deleteProductImageAssignment = `-- name: DeleteProductImageAssignment :exec
DELETE FROM image_assignments WHERE image_id = $1 AND entity_id = $2 AND entity_type = $3
`

type DeleteProductImageAssignmentParams struct {
	ImageID    uuid.UUID `json:"image_id"`
	EntityID   uuid.UUID `json:"entity_id"`
	EntityType string    `json:"entity_type"`
}

func (q *Queries) DeleteProductImageAssignment(ctx context.Context, arg DeleteProductImageAssignmentParams) error {
	_, err := q.db.Exec(ctx, deleteProductImageAssignment, arg.ImageID, arg.EntityID, arg.EntityType)
	return err
}

const getImageFromExternalID = `-- name: GetImageFromExternalID :one
SELECT images.id, external_id, url, alt_text, caption, mime_type, file_size, width, height, uploaded_at, updated_at, image_assignments.id, image_id, entity_id, entity_type, display_order, role, created_at FROM images
JOIN image_assignments ON images.id = image_assignments.image_id
WHERE external_id = $1 LIMIT 1
`

type GetImageFromExternalIDRow struct {
	ID           uuid.UUID `json:"id"`
	ExternalID   string    `json:"external_id"`
	Url          string    `json:"url"`
	AltText      *string   `json:"alt_text"`
	Caption      *string   `json:"caption"`
	MimeType     *string   `json:"mime_type"`
	FileSize     *int64    `json:"file_size"`
	Width        *int32    `json:"width"`
	Height       *int32    `json:"height"`
	UploadedAt   time.Time `json:"uploaded_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	ID_2         uuid.UUID `json:"id_2"`
	ImageID      uuid.UUID `json:"image_id"`
	EntityID     uuid.UUID `json:"entity_id"`
	EntityType   string    `json:"entity_type"`
	DisplayOrder int16     `json:"display_order"`
	Role         string    `json:"role"`
	CreatedAt    time.Time `json:"created_at"`
}

func (q *Queries) GetImageFromExternalID(ctx context.Context, externalID string) (GetImageFromExternalIDRow, error) {
	row := q.db.QueryRow(ctx, getImageFromExternalID, externalID)
	var i GetImageFromExternalIDRow
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Url,
		&i.AltText,
		&i.Caption,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.UploadedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.ImageID,
		&i.EntityID,
		&i.EntityType,
		&i.DisplayOrder,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const getImageFromID = `-- name: GetImageFromID :one
SELECT images.id, external_id, url, alt_text, caption, mime_type, file_size, width, height, uploaded_at, updated_at, image_assignments.id, image_id, entity_id, entity_type, display_order, role, created_at FROM images
JOIN image_assignments ON images.id = image_assignments.image_id
WHERE images.id = $1 AND entity_type = $2 LIMIT 1
`

type GetImageFromIDParams struct {
	ID         uuid.UUID `json:"id"`
	EntityType string    `json:"entity_type"`
}

type GetImageFromIDRow struct {
	ID           uuid.UUID `json:"id"`
	ExternalID   string    `json:"external_id"`
	Url          string    `json:"url"`
	AltText      *string   `json:"alt_text"`
	Caption      *string   `json:"caption"`
	MimeType     *string   `json:"mime_type"`
	FileSize     *int64    `json:"file_size"`
	Width        *int32    `json:"width"`
	Height       *int32    `json:"height"`
	UploadedAt   time.Time `json:"uploaded_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	ID_2         uuid.UUID `json:"id_2"`
	ImageID      uuid.UUID `json:"image_id"`
	EntityID     uuid.UUID `json:"entity_id"`
	EntityType   string    `json:"entity_type"`
	DisplayOrder int16     `json:"display_order"`
	Role         string    `json:"role"`
	CreatedAt    time.Time `json:"created_at"`
}

func (q *Queries) GetImageFromID(ctx context.Context, arg GetImageFromIDParams) (GetImageFromIDRow, error) {
	row := q.db.QueryRow(ctx, getImageFromID, arg.ID, arg.EntityType)
	var i GetImageFromIDRow
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Url,
		&i.AltText,
		&i.Caption,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.UploadedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.ImageID,
		&i.EntityID,
		&i.EntityType,
		&i.DisplayOrder,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const getImagesByEntityID = `-- name: GetImagesByEntityID :many
SELECT image_assignments.id, image_id, entity_id, entity_type, display_order, role, created_at, images.id, external_id, url, alt_text, caption, mime_type, file_size, width, height, uploaded_at, updated_at FROM image_assignments
JOIN images ON images.id = image_assignments.image_id
WHERE entity_id = $1 ORDER BY display_order
`

type GetImagesByEntityIDRow struct {
	ID           uuid.UUID `json:"id"`
	ImageID      uuid.UUID `json:"image_id"`
	EntityID     uuid.UUID `json:"entity_id"`
	EntityType   string    `json:"entity_type"`
	DisplayOrder int16     `json:"display_order"`
	Role         string    `json:"role"`
	CreatedAt    time.Time `json:"created_at"`
	ID_2         uuid.UUID `json:"id_2"`
	ExternalID   string    `json:"external_id"`
	Url          string    `json:"url"`
	AltText      *string   `json:"alt_text"`
	Caption      *string   `json:"caption"`
	MimeType     *string   `json:"mime_type"`
	FileSize     *int64    `json:"file_size"`
	Width        *int32    `json:"width"`
	Height       *int32    `json:"height"`
	UploadedAt   time.Time `json:"uploaded_at"`
	UpdatedAt    time.Time `json:"updated_at"`
}

func (q *Queries) GetImagesByEntityID(ctx context.Context, entityID uuid.UUID) ([]GetImagesByEntityIDRow, error) {
	rows, err := q.db.Query(ctx, getImagesByEntityID, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetImagesByEntityIDRow{}
	for rows.Next() {
		var i GetImagesByEntityIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ImageID,
			&i.EntityID,
			&i.EntityType,
			&i.DisplayOrder,
			&i.Role,
			&i.CreatedAt,
			&i.ID_2,
			&i.ExternalID,
			&i.Url,
			&i.AltText,
			&i.Caption,
			&i.MimeType,
			&i.FileSize,
			&i.Width,
			&i.Height,
			&i.UploadedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductImageByEntityID = `-- name: GetProductImageByEntityID :one
SELECT image_assignments.id, image_id, entity_id, entity_type, display_order, role, created_at, images.id, external_id, url, alt_text, caption, mime_type, file_size, width, height, uploaded_at, updated_at FROM image_assignments
JOIN images ON images.id = image_assignments.image_id
WHERE entity_id = $1 LIMIT 1
`

type GetProductImageByEntityIDRow struct {
	ID           uuid.UUID `json:"id"`
	ImageID      uuid.UUID `json:"image_id"`
	EntityID     uuid.UUID `json:"entity_id"`
	EntityType   string    `json:"entity_type"`
	DisplayOrder int16     `json:"display_order"`
	Role         string    `json:"role"`
	CreatedAt    time.Time `json:"created_at"`
	ID_2         uuid.UUID `json:"id_2"`
	ExternalID   string    `json:"external_id"`
	Url          string    `json:"url"`
	AltText      *string   `json:"alt_text"`
	Caption      *string   `json:"caption"`
	MimeType     *string   `json:"mime_type"`
	FileSize     *int64    `json:"file_size"`
	Width        *int32    `json:"width"`
	Height       *int32    `json:"height"`
	UploadedAt   time.Time `json:"uploaded_at"`
	UpdatedAt    time.Time `json:"updated_at"`
}

func (q *Queries) GetProductImageByEntityID(ctx context.Context, entityID uuid.UUID) (GetProductImageByEntityIDRow, error) {
	row := q.db.QueryRow(ctx, getProductImageByEntityID, entityID)
	var i GetProductImageByEntityIDRow
	err := row.Scan(
		&i.ID,
		&i.ImageID,
		&i.EntityID,
		&i.EntityType,
		&i.DisplayOrder,
		&i.Role,
		&i.CreatedAt,
		&i.ID_2,
		&i.ExternalID,
		&i.Url,
		&i.AltText,
		&i.Caption,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.UploadedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductImagesAssigned = `-- name: GetProductImagesAssigned :many
SELECT 
    images.id,
    images.external_id,
    images.url,
    images.alt_text,
    images.caption,
    images.mime_type,
    images.file_size,
    images.width,
    images.height,
    image_assignments.entity_id,
    image_assignments.entity_type,
    image_assignments.display_order,
    image_assignments.role
FROM images
JOIN image_assignments ON images.id = image_assignments.image_id
WHERE entity_id = ANY($1::UUID[]) ORDER BY entity_id, display_order
`

type GetProductImagesAssignedRow struct {
	ID           uuid.UUID `json:"id"`
	ExternalID   string    `json:"external_id"`
	Url          string    `json:"url"`
	AltText      *string   `json:"alt_text"`
	Caption      *string   `json:"caption"`
	MimeType     *string   `json:"mime_type"`
	FileSize     *int64    `json:"file_size"`
	Width        *int32    `json:"width"`
	Height       *int32    `json:"height"`
	EntityID     uuid.UUID `json:"entity_id"`
	EntityType   string    `json:"entity_type"`
	DisplayOrder int16     `json:"display_order"`
	Role         string    `json:"role"`
}

func (q *Queries) GetProductImagesAssigned(ctx context.Context, entityIds []uuid.UUID) ([]GetProductImagesAssignedRow, error) {
	rows, err := q.db.Query(ctx, getProductImagesAssigned, entityIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductImagesAssignedRow{}
	for rows.Next() {
		var i GetProductImagesAssignedRow
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Url,
			&i.AltText,
			&i.Caption,
			&i.MimeType,
			&i.FileSize,
			&i.Width,
			&i.Height,
			&i.EntityID,
			&i.EntityType,
			&i.DisplayOrder,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type InsertBulkImageAssignmentsParams struct {
	ImageID      uuid.UUID `json:"image_id"`
	EntityID     uuid.UUID `json:"entity_id"`
	EntityType   string    `json:"entity_type"`
	DisplayOrder int16     `json:"display_order"`
	Role         string    `json:"role"`
}

type InsertBulkImagesParams struct {
	ExternalID string  `json:"external_id"`
	Url        string  `json:"url"`
	AltText    *string `json:"alt_text"`
	Caption    *string `json:"caption"`
	MimeType   *string `json:"mime_type"`
	FileSize   *int64  `json:"file_size"`
	Width      *int32  `json:"width"`
	Height     *int32  `json:"height"`
}

const insertImage = `-- name: InsertImage :one
INSERT INTO images (external_id, url, alt_text, caption, mime_type, file_size, width, height) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, external_id, url, alt_text, caption, mime_type, file_size, width, height, uploaded_at, updated_at
`

type InsertImageParams struct {
	ExternalID string  `json:"external_id"`
	Url        string  `json:"url"`
	AltText    *string `json:"alt_text"`
	Caption    *string `json:"caption"`
	MimeType   *string `json:"mime_type"`
	FileSize   *int64  `json:"file_size"`
	Width      *int32  `json:"width"`
	Height     *int32  `json:"height"`
}

func (q *Queries) InsertImage(ctx context.Context, arg InsertImageParams) (Image, error) {
	row := q.db.QueryRow(ctx, insertImage,
		arg.ExternalID,
		arg.Url,
		arg.AltText,
		arg.Caption,
		arg.MimeType,
		arg.FileSize,
		arg.Width,
		arg.Height,
	)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Url,
		&i.AltText,
		&i.Caption,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.UploadedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertImageAssignment = `-- name: InsertImageAssignment :one
INSERT INTO image_assignments (image_id, entity_id, entity_type, display_order, role) VALUES ($1, $2, $3, $4, $5) RETURNING id, image_id, entity_id, entity_type, display_order, role, created_at
`

type InsertImageAssignmentParams struct {
	ImageID      uuid.UUID `json:"image_id"`
	EntityID     uuid.UUID `json:"entity_id"`
	EntityType   string    `json:"entity_type"`
	DisplayOrder int16     `json:"display_order"`
	Role         string    `json:"role"`
}

func (q *Queries) InsertImageAssignment(ctx context.Context, arg InsertImageAssignmentParams) (ImageAssignment, error) {
	row := q.db.QueryRow(ctx, insertImageAssignment,
		arg.ImageID,
		arg.EntityID,
		arg.EntityType,
		arg.DisplayOrder,
		arg.Role,
	)
	var i ImageAssignment
	err := row.Scan(
		&i.ID,
		&i.ImageID,
		&i.EntityID,
		&i.EntityType,
		&i.DisplayOrder,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const updateProductImage = `-- name: UpdateProductImage :exec
UPDATE images 
SET 
    url = COALESCE($2, url),
    external_id = COALESCE($3, external_id) 
WHERE id = $1
`

type UpdateProductImageParams struct {
	ID         uuid.UUID `json:"id"`
	Url        *string   `json:"url"`
	ExternalID *string   `json:"external_id"`
}

func (q *Queries) UpdateProductImage(ctx context.Context, arg UpdateProductImageParams) error {
	_, err := q.db.Exec(ctx, updateProductImage, arg.ID, arg.Url, arg.ExternalID)
	return err
}

const updateProductImageAssignment = `-- name: UpdateProductImageAssignment :exec
UPDATE image_assignments
SET 
    display_order = COALESCE($4, display_order),
    role = COALESCE($5, role)
WHERE image_id = $1 AND entity_id = $2 AND entity_type = $3
`

type UpdateProductImageAssignmentParams struct {
	ImageID      uuid.UUID `json:"image_id"`
	EntityID     uuid.UUID `json:"entity_id"`
	EntityType   string    `json:"entity_type"`
	DisplayOrder *int16    `json:"display_order"`
	Role         *string   `json:"role"`
}

func (q *Queries) UpdateProductImageAssignment(ctx context.Context, arg UpdateProductImageAssignmentParams) error {
	_, err := q.db.Exec(ctx, updateProductImageAssignment,
		arg.ImageID,
		arg.EntityID,
		arg.EntityType,
		arg.DisplayOrder,
		arg.Role,
	)
	return err
}
