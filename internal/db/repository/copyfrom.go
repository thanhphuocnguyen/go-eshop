// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: copyfrom.go

package repository

import (
	"context"
)

// iteratorForAddBulkAttributes implements pgx.CopyFromSource.
type iteratorForAddBulkAttributes struct {
	rows                 []string
	skippedFirstNextCall bool
}

func (r *iteratorForAddBulkAttributes) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForAddBulkAttributes) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0],
	}, nil
}

func (r iteratorForAddBulkAttributes) Err() error {
	return nil
}

func (q *Queries) AddBulkAttributes(ctx context.Context, name []string) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"attributes"}, []string{"name"}, &iteratorForAddBulkAttributes{rows: name})
}

// iteratorForAddBulkProducts implements pgx.CopyFromSource.
type iteratorForAddBulkProducts struct {
	rows                 []AddBulkProductsParams
	skippedFirstNextCall bool
}

func (r *iteratorForAddBulkProducts) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForAddBulkProducts) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].CategoryID,
		r.rows[0].CollectionID,
		r.rows[0].BrandID,
		r.rows[0].Name,
		r.rows[0].Description,
	}, nil
}

func (r iteratorForAddBulkProducts) Err() error {
	return nil
}

func (q *Queries) AddBulkProducts(ctx context.Context, arg []AddBulkProductsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"products"}, []string{"category_id", "collection_id", "brand_id", "name", "description"}, &iteratorForAddBulkProducts{rows: arg})
}

// iteratorForCreateBulkOrderItems implements pgx.CopyFromSource.
type iteratorForCreateBulkOrderItems struct {
	rows                 []CreateBulkOrderItemsParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateBulkOrderItems) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateBulkOrderItems) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].OrderID,
		r.rows[0].VariantID,
		r.rows[0].Quantity,
		r.rows[0].PricePerUnitSnapshot,
		r.rows[0].VariantSkuSnapshot,
		r.rows[0].ProductNameSnapshot,
		r.rows[0].LineTotalSnapshot,
		r.rows[0].AttributesSnapshot,
	}, nil
}

func (r iteratorForCreateBulkOrderItems) Err() error {
	return nil
}

func (q *Queries) CreateBulkOrderItems(ctx context.Context, arg []CreateBulkOrderItemsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"order_items"}, []string{"order_id", "variant_id", "quantity", "price_per_unit_snapshot", "variant_sku_snapshot", "product_name_snapshot", "line_total_snapshot", "attributes_snapshot"}, &iteratorForCreateBulkOrderItems{rows: arg})
}

// iteratorForCreateBulkProductVariantAttribute implements pgx.CopyFromSource.
type iteratorForCreateBulkProductVariantAttribute struct {
	rows                 []CreateBulkProductVariantAttributeParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateBulkProductVariantAttribute) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateBulkProductVariantAttribute) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].VariantID,
		r.rows[0].AttributeValueID,
	}, nil
}

func (r iteratorForCreateBulkProductVariantAttribute) Err() error {
	return nil
}

func (q *Queries) CreateBulkProductVariantAttribute(ctx context.Context, arg []CreateBulkProductVariantAttributeParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"variant_attribute_values"}, []string{"variant_id", "attribute_value_id"}, &iteratorForCreateBulkProductVariantAttribute{rows: arg})
}

// iteratorForCreateBulkProductVariants implements pgx.CopyFromSource.
type iteratorForCreateBulkProductVariants struct {
	rows                 []CreateBulkProductVariantsParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateBulkProductVariants) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateBulkProductVariants) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ProductID,
		r.rows[0].Sku,
		r.rows[0].Price,
		r.rows[0].Stock,
		r.rows[0].Weight,
	}, nil
}

func (r iteratorForCreateBulkProductVariants) Err() error {
	return nil
}

func (q *Queries) CreateBulkProductVariants(ctx context.Context, arg []CreateBulkProductVariantsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"product_variants"}, []string{"product_id", "sku", "price", "stock", "weight"}, &iteratorForCreateBulkProductVariants{rows: arg})
}

// iteratorForInsertBulkCategoryDiscounts implements pgx.CopyFromSource.
type iteratorForInsertBulkCategoryDiscounts struct {
	rows                 []InsertBulkCategoryDiscountsParams
	skippedFirstNextCall bool
}

func (r *iteratorForInsertBulkCategoryDiscounts) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForInsertBulkCategoryDiscounts) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].DiscountID,
		r.rows[0].CategoryID,
	}, nil
}

func (r iteratorForInsertBulkCategoryDiscounts) Err() error {
	return nil
}

func (q *Queries) InsertBulkCategoryDiscounts(ctx context.Context, arg []InsertBulkCategoryDiscountsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"discount_categories"}, []string{"discount_id", "category_id"}, &iteratorForInsertBulkCategoryDiscounts{rows: arg})
}

// iteratorForInsertBulkImageAssignments implements pgx.CopyFromSource.
type iteratorForInsertBulkImageAssignments struct {
	rows                 []InsertBulkImageAssignmentsParams
	skippedFirstNextCall bool
}

func (r *iteratorForInsertBulkImageAssignments) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForInsertBulkImageAssignments) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ImageID,
		r.rows[0].EntityID,
		r.rows[0].EntityType,
		r.rows[0].DisplayOrder,
		r.rows[0].Role,
	}, nil
}

func (r iteratorForInsertBulkImageAssignments) Err() error {
	return nil
}

func (q *Queries) InsertBulkImageAssignments(ctx context.Context, arg []InsertBulkImageAssignmentsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"image_assignments"}, []string{"image_id", "entity_id", "entity_type", "display_order", "role"}, &iteratorForInsertBulkImageAssignments{rows: arg})
}

// iteratorForInsertBulkImages implements pgx.CopyFromSource.
type iteratorForInsertBulkImages struct {
	rows                 []InsertBulkImagesParams
	skippedFirstNextCall bool
}

func (r *iteratorForInsertBulkImages) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForInsertBulkImages) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ExternalID,
		r.rows[0].Url,
		r.rows[0].AltText,
		r.rows[0].Caption,
		r.rows[0].MimeType,
		r.rows[0].FileSize,
		r.rows[0].Width,
		r.rows[0].Height,
	}, nil
}

func (r iteratorForInsertBulkImages) Err() error {
	return nil
}

func (q *Queries) InsertBulkImages(ctx context.Context, arg []InsertBulkImagesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"images"}, []string{"external_id", "url", "alt_text", "caption", "mime_type", "file_size", "width", "height"}, &iteratorForInsertBulkImages{rows: arg})
}

// iteratorForInsertBulkProductDiscounts implements pgx.CopyFromSource.
type iteratorForInsertBulkProductDiscounts struct {
	rows                 []InsertBulkProductDiscountsParams
	skippedFirstNextCall bool
}

func (r *iteratorForInsertBulkProductDiscounts) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForInsertBulkProductDiscounts) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].DiscountID,
		r.rows[0].ProductID,
	}, nil
}

func (r iteratorForInsertBulkProductDiscounts) Err() error {
	return nil
}

func (q *Queries) InsertBulkProductDiscounts(ctx context.Context, arg []InsertBulkProductDiscountsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"discount_products"}, []string{"discount_id", "product_id"}, &iteratorForInsertBulkProductDiscounts{rows: arg})
}

// iteratorForInsertBulkUserDiscounts implements pgx.CopyFromSource.
type iteratorForInsertBulkUserDiscounts struct {
	rows                 []InsertBulkUserDiscountsParams
	skippedFirstNextCall bool
}

func (r *iteratorForInsertBulkUserDiscounts) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForInsertBulkUserDiscounts) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].DiscountID,
		r.rows[0].UserID,
	}, nil
}

func (r iteratorForInsertBulkUserDiscounts) Err() error {
	return nil
}

func (q *Queries) InsertBulkUserDiscounts(ctx context.Context, arg []InsertBulkUserDiscountsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"discount_users"}, []string{"discount_id", "user_id"}, &iteratorForInsertBulkUserDiscounts{rows: arg})
}

// iteratorForSeedAddresses implements pgx.CopyFromSource.
type iteratorForSeedAddresses struct {
	rows                 []SeedAddressesParams
	skippedFirstNextCall bool
}

func (r *iteratorForSeedAddresses) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForSeedAddresses) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].UserID,
		r.rows[0].Phone,
		r.rows[0].Street,
		r.rows[0].Ward,
		r.rows[0].District,
		r.rows[0].City,
		r.rows[0].Default,
	}, nil
}

func (r iteratorForSeedAddresses) Err() error {
	return nil
}

func (q *Queries) SeedAddresses(ctx context.Context, arg []SeedAddressesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"user_addresses"}, []string{"user_id", "phone", "street", "ward", "district", "city", "default"}, &iteratorForSeedAddresses{rows: arg})
}

// iteratorForSeedCategories implements pgx.CopyFromSource.
type iteratorForSeedCategories struct {
	rows                 []SeedCategoriesParams
	skippedFirstNextCall bool
}

func (r *iteratorForSeedCategories) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForSeedCategories) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].Name,
		r.rows[0].Slug,
		r.rows[0].Description,
		r.rows[0].ImageUrl,
		r.rows[0].ImageID,
	}, nil
}

func (r iteratorForSeedCategories) Err() error {
	return nil
}

func (q *Queries) SeedCategories(ctx context.Context, arg []SeedCategoriesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"categories"}, []string{"name", "slug", "description", "image_url", "image_id"}, &iteratorForSeedCategories{rows: arg})
}

// iteratorForSeedCollections implements pgx.CopyFromSource.
type iteratorForSeedCollections struct {
	rows                 []SeedCollectionsParams
	skippedFirstNextCall bool
}

func (r *iteratorForSeedCollections) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForSeedCollections) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].Name,
		r.rows[0].Description,
		r.rows[0].ImageUrl,
	}, nil
}

func (r iteratorForSeedCollections) Err() error {
	return nil
}

func (q *Queries) SeedCollections(ctx context.Context, arg []SeedCollectionsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"collections"}, []string{"name", "description", "image_url"}, &iteratorForSeedCollections{rows: arg})
}

// iteratorForSeedUsers implements pgx.CopyFromSource.
type iteratorForSeedUsers struct {
	rows                 []SeedUsersParams
	skippedFirstNextCall bool
}

func (r *iteratorForSeedUsers) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForSeedUsers) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].Email,
		r.rows[0].Username,
		r.rows[0].Phone,
		r.rows[0].Fullname,
		r.rows[0].HashedPassword,
		r.rows[0].Role,
	}, nil
}

func (r iteratorForSeedUsers) Err() error {
	return nil
}

func (q *Queries) SeedUsers(ctx context.Context, arg []SeedUsersParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"users"}, []string{"email", "username", "phone", "fullname", "hashed_password", "role"}, &iteratorForSeedUsers{rows: arg})
}
