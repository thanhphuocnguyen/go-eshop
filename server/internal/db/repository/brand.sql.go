// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: brand.sql

package repository

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countBrands = `-- name: CountBrands :one
SELECT count(*)
FROM brands
WHERE brand_id = COALESCE($1, brand_id)
`

func (q *Queries) CountBrands(ctx context.Context, brandID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countBrands, brandID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBrand = `-- name: CreateBrand :one
INSERT INTO brands (name, description, image_url)
VALUES (
    $1,
    $2,
    $3
)
RETURNING brand_id, name, image_url, description, created_at, updated_at
`

type CreateBrandParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	ImageUrl    pgtype.Text `json:"image_url"`
}

func (q *Queries) CreateBrand(ctx context.Context, arg CreateBrandParams) (Brand, error) {
	row := q.db.QueryRow(ctx, createBrand, arg.Name, arg.Description, arg.ImageUrl)
	var i Brand
	err := row.Scan(
		&i.BrandID,
		&i.Name,
		&i.ImageUrl,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBrand = `-- name: DeleteBrand :exec
DELETE FROM brands WHERE brand_id = $1
`

func (q *Queries) DeleteBrand(ctx context.Context, brandID int32) error {
	_, err := q.db.Exec(ctx, deleteBrand, brandID)
	return err
}

const getBrandByID = `-- name: GetBrandByID :one
SELECT c.brand_id, c.name, c.image_url, c.description, c.created_at, c.updated_at FROM brands c WHERE c.brand_id = $1 LIMIT 1
`

func (q *Queries) GetBrandByID(ctx context.Context, brandID int32) (Brand, error) {
	row := q.db.QueryRow(ctx, getBrandByID, brandID)
	var i Brand
	err := row.Scan(
		&i.BrandID,
		&i.Name,
		&i.ImageUrl,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBrands = `-- name: GetBrands :many
SELECT 
    c.brand_id, c.name, c.image_url, c.description, c.created_at, c.updated_at, 
    p.name as product_name, p.product_id, p.description,
    MIN(pv.price) as price_from, 
    MAX(pv.price) as price_to, 
    MAX(pv.discount) as discount, 
    MIN(pv.stock_quantity) as stock_quantity, 
    COUNT(pv.variant_id) as variant_count,
    img.image_id, img.image_url
FROM brands AS c
LEFT JOIN products AS p ON p.brand_id = c.brand_id
LEFT JOIN product_variants AS pv ON p.product_id = pv.product_id
LEFT JOIN images AS img ON p.product_id = img.product_id
GROUP BY c.brand_id, p.product_id, img.image_id, img.image_url
LIMIT $1 OFFSET $2
`

type GetBrandsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetBrandsRow struct {
	BrandID       int32       `json:"brand_id"`
	Name          string      `json:"name"`
	ImageUrl      pgtype.Text `json:"image_url"`
	Description   pgtype.Text `json:"description"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	ProductName   pgtype.Text `json:"product_name"`
	ProductID     pgtype.UUID `json:"product_id"`
	Description_2 pgtype.Text `json:"description_2"`
	PriceFrom     interface{} `json:"price_from"`
	PriceTo       interface{} `json:"price_to"`
	Discount      interface{} `json:"discount"`
	StockQuantity interface{} `json:"stock_quantity"`
	VariantCount  int64       `json:"variant_count"`
	ImageID       pgtype.Int4 `json:"image_id"`
	ImageUrl_2    pgtype.Text `json:"image_url_2"`
}

func (q *Queries) GetBrands(ctx context.Context, arg GetBrandsParams) ([]GetBrandsRow, error) {
	rows, err := q.db.Query(ctx, getBrands, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBrandsRow
	for rows.Next() {
		var i GetBrandsRow
		if err := rows.Scan(
			&i.BrandID,
			&i.Name,
			&i.ImageUrl,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductID,
			&i.Description_2,
			&i.PriceFrom,
			&i.PriceTo,
			&i.Discount,
			&i.StockQuantity,
			&i.VariantCount,
			&i.ImageID,
			&i.ImageUrl_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBrandsByIDs = `-- name: GetBrandsByIDs :many
SELECT 
    c.brand_id, c.name, c.image_url, c.description, c.created_at, c.updated_at, 
    p.name as product_name, p.product_id, p.description,
    MIN(pv.price) as price_from, 
    MAX(pv.price) as price_to, 
    MAX(pv.discount) as discount, 
    MIN(pv.stock_quantity) as stock_quantity, 
    COUNT(pv.variant_id) as variant_count,
    img.image_id, img.image_url
FROM brands AS c
LEFT JOIN products AS p ON p.brand_id = c.brand_id
LEFT JOIN product_variants AS pv ON p.product_id = pv.product_id
LEFT JOIN images AS img ON p.product_id = img.product_id
WHERE c.brand_id = ANY($3::int[])
GROUP BY c.brand_id, p.product_id, img.image_id, img.image_url
LIMIT $1 OFFSET $2
`

type GetBrandsByIDsParams struct {
	Limit    int32   `json:"limit"`
	Offset   int32   `json:"offset"`
	BrandIds []int32 `json:"brand_ids"`
}

type GetBrandsByIDsRow struct {
	BrandID       int32       `json:"brand_id"`
	Name          string      `json:"name"`
	ImageUrl      pgtype.Text `json:"image_url"`
	Description   pgtype.Text `json:"description"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	ProductName   pgtype.Text `json:"product_name"`
	ProductID     pgtype.UUID `json:"product_id"`
	Description_2 pgtype.Text `json:"description_2"`
	PriceFrom     interface{} `json:"price_from"`
	PriceTo       interface{} `json:"price_to"`
	Discount      interface{} `json:"discount"`
	StockQuantity interface{} `json:"stock_quantity"`
	VariantCount  int64       `json:"variant_count"`
	ImageID       pgtype.Int4 `json:"image_id"`
	ImageUrl_2    pgtype.Text `json:"image_url_2"`
}

func (q *Queries) GetBrandsByIDs(ctx context.Context, arg GetBrandsByIDsParams) ([]GetBrandsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getBrandsByIDs, arg.Limit, arg.Offset, arg.BrandIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBrandsByIDsRow
	for rows.Next() {
		var i GetBrandsByIDsRow
		if err := rows.Scan(
			&i.BrandID,
			&i.Name,
			&i.ImageUrl,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductID,
			&i.Description_2,
			&i.PriceFrom,
			&i.PriceTo,
			&i.Discount,
			&i.StockQuantity,
			&i.VariantCount,
			&i.ImageID,
			&i.ImageUrl_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBrandWith = `-- name: UpdateBrandWith :one
UPDATE brands
SET 
    name = COALESCE($2, name), 
    image_url = COALESCE($3, image_url), 
    description = COALESCE($4, description),
    updated_at = now()
WHERE brand_id = $1
RETURNING brand_id, name, image_url, description, created_at, updated_at
`

type UpdateBrandWithParams struct {
	BrandID     int32       `json:"brand_id"`
	Name        pgtype.Text `json:"name"`
	ImageUrl    pgtype.Text `json:"image_url"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateBrandWith(ctx context.Context, arg UpdateBrandWithParams) (Brand, error) {
	row := q.db.QueryRow(ctx, updateBrandWith,
		arg.BrandID,
		arg.Name,
		arg.ImageUrl,
		arg.Description,
	)
	var i Brand
	err := row.Scan(
		&i.BrandID,
		&i.Name,
		&i.ImageUrl,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
