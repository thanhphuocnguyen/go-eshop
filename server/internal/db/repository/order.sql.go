// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: order.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countOrders = `-- name: CountOrders :one
SELECT
    COUNT(*)
FROM
    orders
WHERE
    customer_id = $1 AND
    status = COALESCE($2, status) AND
    created_at >= COALESCE($3, created_at) AND
    created_at <= COALESCE($4, created_at)
`

type CountOrdersParams struct {
	CustomerID uuid.UUID          `json:"customer_id"`
	Status     NullOrderStatus    `json:"status"`
	StartDate  pgtype.Timestamptz `json:"start_date"`
	EndDate    pgtype.Timestamptz `json:"end_date"`
}

func (q *Queries) CountOrders(ctx context.Context, arg CountOrdersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders,
		arg.CustomerID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

type CreateBulkOrderItemsParams struct {
	ID                   uuid.UUID      `json:"id"`
	OrderID              uuid.UUID      `json:"order_id"`
	VariantID            uuid.UUID      `json:"variant_id"`
	Quantity             int16          `json:"quantity"`
	PricePerUnitSnapshot pgtype.Numeric `json:"price_per_unit_snapshot"`
	VariantSkuSnapshot   string         `json:"variant_sku_snapshot"`
	ProductNameSnapshot  string         `json:"product_name_snapshot"`
	LineTotalSnapshot    pgtype.Numeric `json:"line_total_snapshot"`
	AttributesSnapshot   []byte         `json:"attributes_snapshot"`
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    id,
    customer_id,
    user_address_id,
    customer_email,
    customer_name,
    customer_phone,
    total_price
)
VALUES 
    ($1,$2,$3,$4, $5, $6, $7)
RETURNING id, customer_id, customer_email, customer_name, customer_phone, user_address_id, total_price, status, confirmed_at, delivered_at, cancelled_at, refunded_at, order_date, shipping_address, updated_at, created_at
`

type CreateOrderParams struct {
	ID            uuid.UUID      `json:"id"`
	CustomerID    uuid.UUID      `json:"customer_id"`
	UserAddressID int64          `json:"user_address_id"`
	CustomerEmail string         `json:"customer_email"`
	CustomerName  string         `json:"customer_name"`
	CustomerPhone pgtype.Text    `json:"customer_phone"`
	TotalPrice    pgtype.Numeric `json:"total_price"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.ID,
		arg.CustomerID,
		arg.UserAddressID,
		arg.CustomerEmail,
		arg.CustomerName,
		arg.CustomerPhone,
		arg.TotalPrice,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.UserAddressID,
		&i.TotalPrice,
		&i.Status,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.RefundedAt,
		&i.OrderDate,
		&i.ShippingAddress,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO
    order_items (id, order_id, variant_id, quantity, price_per_unit_snapshot, variant_sku_snapshot, product_name_snapshot, line_total_snapshot, attributes_snapshot)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, order_id, variant_id, price_per_unit_snapshot, line_total_snapshot, product_name_snapshot, variant_sku_snapshot, attributes_snapshot, quantity, created_at, updated_at
`

type CreateOrderItemParams struct {
	ID                   uuid.UUID      `json:"id"`
	OrderID              uuid.UUID      `json:"order_id"`
	VariantID            uuid.UUID      `json:"variant_id"`
	Quantity             int16          `json:"quantity"`
	PricePerUnitSnapshot pgtype.Numeric `json:"price_per_unit_snapshot"`
	VariantSkuSnapshot   string         `json:"variant_sku_snapshot"`
	ProductNameSnapshot  string         `json:"product_name_snapshot"`
	LineTotalSnapshot    pgtype.Numeric `json:"line_total_snapshot"`
	AttributesSnapshot   []byte         `json:"attributes_snapshot"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.ID,
		arg.OrderID,
		arg.VariantID,
		arg.Quantity,
		arg.PricePerUnitSnapshot,
		arg.VariantSkuSnapshot,
		arg.ProductNameSnapshot,
		arg.LineTotalSnapshot,
		arg.AttributesSnapshot,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.VariantID,
		&i.PricePerUnitSnapshot,
		&i.LineTotalSnapshot,
		&i.ProductNameSnapshot,
		&i.VariantSkuSnapshot,
		&i.AttributesSnapshot,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM
    orders
WHERE
    id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrder, id)
	return err
}

const getOrder = `-- name: GetOrder :one
SELECT
    id, customer_id, customer_email, customer_name, customer_phone, user_address_id, total_price, status, confirmed_at, delivered_at, cancelled_at, refunded_at, order_date, shipping_address, updated_at, created_at
FROM
    orders ord
WHERE
    id = $1
LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.UserAddressID,
		&i.TotalPrice,
		&i.Status,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.RefundedAt,
		&i.OrderDate,
		&i.ShippingAddress,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderDetails = `-- name: GetOrderDetails :many
SELECT
    ord.id, ord.customer_id, ord.customer_email, ord.customer_name, ord.customer_phone, ord.user_address_id, ord.total_price, ord.status, ord.confirmed_at, ord.delivered_at, ord.cancelled_at, ord.refunded_at, ord.order_date, ord.shipping_address, ord.updated_at, ord.created_at, 
    oi.quantity, oi.price_per_unit_snapshot, oi.variant_sku_snapshot, oi.product_name_snapshot, oi.line_total_snapshot,
    oi.attributes_snapshot, oi.id as order_item_id,
    p.name as product_name, p.id as variant_id,
    u_addr.street, u_addr.ward, u_addr.district, u_addr.city, 
    img.url as image_url,
    pm.status as payment_status, pm.id as payment_id, pm.amount as payment_amount, pm.payment_method, pm.payment_gateway, pm.refund_id
FROM
    orders ord
JOIN
    order_items oi ON oi.id = ord.id
JOIN
    products p ON oi.variant_id = p.id
JOIN
    user_addresses u_addr ON ord.user_address_id = u_addr.user_address_id
LEFT JOIN
    payments pm ON ord.id = pm.id
LEFT JOIN 
    image_assignments ia ON p.id = ia.entity_id AND ia.entity_type = 'product'
LEFT JOIN
    images img ON img.id = ia.image_id
WHERE
    ord.id = $1
`

type GetOrderDetailsRow struct {
	ID                   uuid.UUID          `json:"id"`
	CustomerID           uuid.UUID          `json:"customer_id"`
	CustomerEmail        string             `json:"customer_email"`
	CustomerName         string             `json:"customer_name"`
	CustomerPhone        pgtype.Text        `json:"customer_phone"`
	UserAddressID        int64              `json:"user_address_id"`
	TotalPrice           pgtype.Numeric     `json:"total_price"`
	Status               OrderStatus        `json:"status"`
	ConfirmedAt          pgtype.Timestamptz `json:"confirmed_at"`
	DeliveredAt          pgtype.Timestamptz `json:"delivered_at"`
	CancelledAt          pgtype.Timestamptz `json:"cancelled_at"`
	RefundedAt           pgtype.Timestamptz `json:"refunded_at"`
	OrderDate            time.Time          `json:"order_date"`
	ShippingAddress      []byte             `json:"shipping_address"`
	UpdatedAt            time.Time          `json:"updated_at"`
	CreatedAt            time.Time          `json:"created_at"`
	Quantity             int16              `json:"quantity"`
	PricePerUnitSnapshot pgtype.Numeric     `json:"price_per_unit_snapshot"`
	VariantSkuSnapshot   string             `json:"variant_sku_snapshot"`
	ProductNameSnapshot  string             `json:"product_name_snapshot"`
	LineTotalSnapshot    pgtype.Numeric     `json:"line_total_snapshot"`
	AttributesSnapshot   []byte             `json:"attributes_snapshot"`
	OrderItemID          uuid.UUID          `json:"order_item_id"`
	ProductName          string             `json:"product_name"`
	VariantID            uuid.UUID          `json:"variant_id"`
	Street               string             `json:"street"`
	Ward                 pgtype.Text        `json:"ward"`
	District             string             `json:"district"`
	City                 string             `json:"city"`
	ImageUrl             pgtype.Text        `json:"image_url"`
	PaymentStatus        NullPaymentStatus  `json:"payment_status"`
	PaymentID            pgtype.Text        `json:"payment_id"`
	PaymentAmount        pgtype.Numeric     `json:"payment_amount"`
	PaymentMethod        NullPaymentMethod  `json:"payment_method"`
	PaymentGateway       NullPaymentGateway `json:"payment_gateway"`
	RefundID             pgtype.Text        `json:"refund_id"`
}

func (q *Queries) GetOrderDetails(ctx context.Context, id uuid.UUID) ([]GetOrderDetailsRow, error) {
	rows, err := q.db.Query(ctx, getOrderDetails, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderDetailsRow{}
	for rows.Next() {
		var i GetOrderDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.CustomerEmail,
			&i.CustomerName,
			&i.CustomerPhone,
			&i.UserAddressID,
			&i.TotalPrice,
			&i.Status,
			&i.ConfirmedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.RefundedAt,
			&i.OrderDate,
			&i.ShippingAddress,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Quantity,
			&i.PricePerUnitSnapshot,
			&i.VariantSkuSnapshot,
			&i.ProductNameSnapshot,
			&i.LineTotalSnapshot,
			&i.AttributesSnapshot,
			&i.OrderItemID,
			&i.ProductName,
			&i.VariantID,
			&i.Street,
			&i.Ward,
			&i.District,
			&i.City,
			&i.ImageUrl,
			&i.PaymentStatus,
			&i.PaymentID,
			&i.PaymentAmount,
			&i.PaymentMethod,
			&i.PaymentGateway,
			&i.RefundID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItems = `-- name: ListOrderItems :many
SELECT
    id, order_id, variant_id, price_per_unit_snapshot, line_total_snapshot, product_name_snapshot, variant_sku_snapshot, attributes_snapshot, quantity, created_at, updated_at
FROM
    order_items
WHERE
    order_id = $1
ORDER BY
    id
LIMIT $2
OFFSET $3
`

type ListOrderItemsParams struct {
	OrderID uuid.UUID `json:"order_id"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) ListOrderItems(ctx context.Context, arg ListOrderItemsParams) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, listOrderItems, arg.OrderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.VariantID,
			&i.PricePerUnitSnapshot,
			&i.LineTotalSnapshot,
			&i.ProductNameSnapshot,
			&i.VariantSkuSnapshot,
			&i.AttributesSnapshot,
			&i.Quantity,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many
SELECT
    ord.id, ord.customer_id, ord.customer_email, ord.customer_name, ord.customer_phone, ord.user_address_id, ord.total_price, ord.status, ord.confirmed_at, ord.delivered_at, ord.cancelled_at, ord.refunded_at, ord.order_date, ord.shipping_address, ord.updated_at, ord.created_at, pm.status as payment_status, COUNT(oit.id) as total_items
FROM
    orders ord
JOIN order_items oit ON ord.id = oit.id
LEFT JOIN payments pm ON ord.id = pm.id
WHERE
    customer_id = COALESCE($3, customer_id) AND
    ord.status = COALESCE($4, ord.status) AND
    ord.created_at >= COALESCE($5, ord.created_at) AND
    ord.created_at <= COALESCE($6, ord.created_at)
GROUP BY ord.id, pm.status
ORDER BY
    ord.created_at DESC
LIMIT $1
OFFSET $2
`

type ListOrdersParams struct {
	Limit      int32              `json:"limit"`
	Offset     int32              `json:"offset"`
	CustomerID pgtype.UUID        `json:"customer_id"`
	Status     NullOrderStatus    `json:"status"`
	StartDate  pgtype.Timestamptz `json:"start_date"`
	EndDate    pgtype.Timestamptz `json:"end_date"`
}

type ListOrdersRow struct {
	ID              uuid.UUID          `json:"id"`
	CustomerID      uuid.UUID          `json:"customer_id"`
	CustomerEmail   string             `json:"customer_email"`
	CustomerName    string             `json:"customer_name"`
	CustomerPhone   pgtype.Text        `json:"customer_phone"`
	UserAddressID   int64              `json:"user_address_id"`
	TotalPrice      pgtype.Numeric     `json:"total_price"`
	Status          OrderStatus        `json:"status"`
	ConfirmedAt     pgtype.Timestamptz `json:"confirmed_at"`
	DeliveredAt     pgtype.Timestamptz `json:"delivered_at"`
	CancelledAt     pgtype.Timestamptz `json:"cancelled_at"`
	RefundedAt      pgtype.Timestamptz `json:"refunded_at"`
	OrderDate       time.Time          `json:"order_date"`
	ShippingAddress []byte             `json:"shipping_address"`
	UpdatedAt       time.Time          `json:"updated_at"`
	CreatedAt       time.Time          `json:"created_at"`
	PaymentStatus   NullPaymentStatus  `json:"payment_status"`
	TotalItems      int64              `json:"total_items"`
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]ListOrdersRow, error) {
	rows, err := q.db.Query(ctx, listOrders,
		arg.Limit,
		arg.Offset,
		arg.CustomerID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrdersRow{}
	for rows.Next() {
		var i ListOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.CustomerEmail,
			&i.CustomerName,
			&i.CustomerPhone,
			&i.UserAddressID,
			&i.TotalPrice,
			&i.Status,
			&i.ConfirmedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.RefundedAt,
			&i.OrderDate,
			&i.ShippingAddress,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.PaymentStatus,
			&i.TotalItems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE
    orders
SET
    status = coalesce($1, status),
    confirmed_at = coalesce($2, confirmed_at),
    cancelled_at = coalesce($3, cancelled_at),
    delivered_at = coalesce($4, delivered_at),
    user_address_id = coalesce($5, user_address_id),
    updated_at = now()
WHERE
    id = $6
RETURNING id, customer_id, customer_email, customer_name, customer_phone, user_address_id, total_price, status, confirmed_at, delivered_at, cancelled_at, refunded_at, order_date, shipping_address, updated_at, created_at
`

type UpdateOrderParams struct {
	Status        NullOrderStatus    `json:"status"`
	ConfirmedAt   pgtype.Timestamptz `json:"confirmed_at"`
	CancelledAt   pgtype.Timestamptz `json:"cancelled_at"`
	DeliveredAt   pgtype.Timestamptz `json:"delivered_at"`
	UserAddressID pgtype.Int8        `json:"user_address_id"`
	ID            uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder,
		arg.Status,
		arg.ConfirmedAt,
		arg.CancelledAt,
		arg.DeliveredAt,
		arg.UserAddressID,
		arg.ID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.UserAddressID,
		&i.TotalPrice,
		&i.Status,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.RefundedAt,
		&i.OrderDate,
		&i.ShippingAddress,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
