// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: order.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countOrders = `-- name: CountOrders :one
SELECT
    COUNT(*)
FROM
    orders
WHERE
    user_id = $1 AND
    status = COALESCE($2, status) AND
    created_at >= COALESCE($3, created_at) AND
    created_at <= COALESCE($4, created_at)
`

type CountOrdersParams struct {
	UserID    uuid.UUID          `json:"user_id"`
	Status    NullOrderStatus    `json:"status"`
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

func (q *Queries) CountOrders(ctx context.Context, arg CountOrdersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders,
		arg.UserID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (order_id,user_id,user_address_id,total_price) VALUES ($1,$2,$3,$4) RETURNING order_id, user_id, user_address_id, total_price, status, confirmed_at, delivered_at, cancelled_at, refunded_at, updated_at, created_at
`

type CreateOrderParams struct {
	OrderID       uuid.UUID      `json:"order_id"`
	UserID        uuid.UUID      `json:"user_id"`
	UserAddressID int64          `json:"user_address_id"`
	TotalPrice    pgtype.Numeric `json:"total_price"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.OrderID,
		arg.UserID,
		arg.UserAddressID,
		arg.TotalPrice,
	)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.UserID,
		&i.UserAddressID,
		&i.TotalPrice,
		&i.Status,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.RefundedAt,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO
    order_items (
        product_id,
        variant_id,
        order_id,
        quantity,
        price
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5
    )
RETURNING order_item_id, order_id, product_id, variant_id, quantity, price, created_at
`

type CreateOrderItemParams struct {
	ProductID int64          `json:"product_id"`
	VariantID int64          `json:"variant_id"`
	OrderID   uuid.UUID      `json:"order_id"`
	Quantity  int16          `json:"quantity"`
	Price     pgtype.Numeric `json:"price"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.ProductID,
		arg.VariantID,
		arg.OrderID,
		arg.Quantity,
		arg.Price,
	)
	var i OrderItem
	err := row.Scan(
		&i.OrderItemID,
		&i.OrderID,
		&i.ProductID,
		&i.VariantID,
		&i.Quantity,
		&i.Price,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM
    orders
WHERE
    order_id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, orderID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrder, orderID)
	return err
}

const getOrder = `-- name: GetOrder :one
SELECT
    order_id, user_id, user_address_id, total_price, status, confirmed_at, delivered_at, cancelled_at, refunded_at, updated_at, created_at
FROM
    orders ord
WHERE
    order_id = $1
LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, orderID uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.UserID,
		&i.UserAddressID,
		&i.TotalPrice,
		&i.Status,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.RefundedAt,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderDetails = `-- name: GetOrderDetails :many
SELECT
    ord.order_id, ord.user_id, ord.user_address_id, ord.total_price, ord.status, ord.confirmed_at, ord.delivered_at, ord.cancelled_at, ord.refunded_at, ord.updated_at, ord.created_at, 
    oi.quantity, oi.price as item_price, oi.order_item_id,
    p.name as product_name, p.product_id,
    u_addr.street, u_addr.ward, u_addr.district, u_addr.city, 
    images.image_url,
    pm.status as payment_status, pm.payment_id, pm.amount as payment_amount, pm.payment_method, pm.payment_gateway, pm.refund_id,
    pv.variant_id
FROM
    orders ord
JOIN
    order_items oi ON oi.order_id = ord.order_id
JOIN
    products p ON oi.product_id = p.product_id
JOIN 
    product_variants AS pv ON oi.variant_id = pv.variant_id
JOIN
    user_addresses u_addr ON ord.user_address_id = u_addr.user_address_id
LEFT JOIN
    payments pm ON ord.order_id = pm.order_id
LEFT JOIN 
    images ON p.product_id = images.product_id
WHERE
    ord.order_id = $1
`

type GetOrderDetailsRow struct {
	OrderID        uuid.UUID          `json:"order_id"`
	UserID         uuid.UUID          `json:"user_id"`
	UserAddressID  int64              `json:"user_address_id"`
	TotalPrice     pgtype.Numeric     `json:"total_price"`
	Status         OrderStatus        `json:"status"`
	ConfirmedAt    pgtype.Timestamptz `json:"confirmed_at"`
	DeliveredAt    pgtype.Timestamptz `json:"delivered_at"`
	CancelledAt    pgtype.Timestamptz `json:"cancelled_at"`
	RefundedAt     pgtype.Timestamptz `json:"refunded_at"`
	UpdatedAt      time.Time          `json:"updated_at"`
	CreatedAt      time.Time          `json:"created_at"`
	Quantity       int16              `json:"quantity"`
	ItemPrice      pgtype.Numeric     `json:"item_price"`
	OrderItemID    int64              `json:"order_item_id"`
	ProductName    string             `json:"product_name"`
	ProductID      int64              `json:"product_id"`
	Street         string             `json:"street"`
	Ward           pgtype.Text        `json:"ward"`
	District       string             `json:"district"`
	City           string             `json:"city"`
	ImageUrl       pgtype.Text        `json:"image_url"`
	PaymentStatus  NullPaymentStatus  `json:"payment_status"`
	PaymentID      pgtype.Text        `json:"payment_id"`
	PaymentAmount  pgtype.Numeric     `json:"payment_amount"`
	PaymentMethod  NullPaymentMethod  `json:"payment_method"`
	PaymentGateway NullPaymentGateway `json:"payment_gateway"`
	RefundID       pgtype.Text        `json:"refund_id"`
	VariantID      int64              `json:"variant_id"`
}

func (q *Queries) GetOrderDetails(ctx context.Context, orderID uuid.UUID) ([]GetOrderDetailsRow, error) {
	rows, err := q.db.Query(ctx, getOrderDetails, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderDetailsRow
	for rows.Next() {
		var i GetOrderDetailsRow
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.UserAddressID,
			&i.TotalPrice,
			&i.Status,
			&i.ConfirmedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.RefundedAt,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Quantity,
			&i.ItemPrice,
			&i.OrderItemID,
			&i.ProductName,
			&i.ProductID,
			&i.Street,
			&i.Ward,
			&i.District,
			&i.City,
			&i.ImageUrl,
			&i.PaymentStatus,
			&i.PaymentID,
			&i.PaymentAmount,
			&i.PaymentMethod,
			&i.PaymentGateway,
			&i.RefundID,
			&i.VariantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItems = `-- name: ListOrderItems :many
SELECT
    order_item_id, order_id, product_id, variant_id, quantity, price, created_at
FROM
    order_items
WHERE
    order_id = $1
ORDER BY
    order_item_id
LIMIT $2
OFFSET $3
`

type ListOrderItemsParams struct {
	OrderID uuid.UUID `json:"order_id"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) ListOrderItems(ctx context.Context, arg ListOrderItemsParams) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, listOrderItems, arg.OrderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderItem
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.OrderItemID,
			&i.OrderID,
			&i.ProductID,
			&i.VariantID,
			&i.Quantity,
			&i.Price,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many
SELECT
    ord.order_id, ord.user_id, ord.user_address_id, ord.total_price, ord.status, ord.confirmed_at, ord.delivered_at, ord.cancelled_at, ord.refunded_at, ord.updated_at, ord.created_at, pm.status as payment_status, COUNT(oit.order_item_id) as total_items
FROM
    orders ord
JOIN order_items oit ON ord.order_id = oit.order_id
LEFT JOIN payments pm ON ord.order_id = pm.order_id
WHERE
    user_id = COALESCE($3, user_id) AND
    ord.status = COALESCE($4, ord.status) AND
    ord.created_at >= COALESCE($5, ord.created_at) AND
    ord.created_at <= COALESCE($6, ord.created_at)
GROUP BY ord.order_id, pm.status
ORDER BY
    ord.created_at DESC
LIMIT $1
OFFSET $2
`

type ListOrdersParams struct {
	Limit     int32              `json:"limit"`
	Offset    int32              `json:"offset"`
	UserID    pgtype.UUID        `json:"user_id"`
	Status    NullOrderStatus    `json:"status"`
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

type ListOrdersRow struct {
	OrderID       uuid.UUID          `json:"order_id"`
	UserID        uuid.UUID          `json:"user_id"`
	UserAddressID int64              `json:"user_address_id"`
	TotalPrice    pgtype.Numeric     `json:"total_price"`
	Status        OrderStatus        `json:"status"`
	ConfirmedAt   pgtype.Timestamptz `json:"confirmed_at"`
	DeliveredAt   pgtype.Timestamptz `json:"delivered_at"`
	CancelledAt   pgtype.Timestamptz `json:"cancelled_at"`
	RefundedAt    pgtype.Timestamptz `json:"refunded_at"`
	UpdatedAt     time.Time          `json:"updated_at"`
	CreatedAt     time.Time          `json:"created_at"`
	PaymentStatus NullPaymentStatus  `json:"payment_status"`
	TotalItems    int64              `json:"total_items"`
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]ListOrdersRow, error) {
	rows, err := q.db.Query(ctx, listOrders,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersRow
	for rows.Next() {
		var i ListOrdersRow
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.UserAddressID,
			&i.TotalPrice,
			&i.Status,
			&i.ConfirmedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.RefundedAt,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.PaymentStatus,
			&i.TotalItems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE
    orders
SET
    status = coalesce($1, status),
    confirmed_at = coalesce($2, confirmed_at),
    cancelled_at = coalesce($3, cancelled_at),
    delivered_at = coalesce($4, delivered_at),
    user_address_id = coalesce($5, user_address_id),
    updated_at = now()
WHERE
    order_id = $6
RETURNING order_id, user_id, user_address_id, total_price, status, confirmed_at, delivered_at, cancelled_at, refunded_at, updated_at, created_at
`

type UpdateOrderParams struct {
	Status        NullOrderStatus    `json:"status"`
	ConfirmedAt   pgtype.Timestamptz `json:"confirmed_at"`
	CancelledAt   pgtype.Timestamptz `json:"cancelled_at"`
	DeliveredAt   pgtype.Timestamptz `json:"delivered_at"`
	UserAddressID pgtype.Int8        `json:"user_address_id"`
	OrderID       uuid.UUID          `json:"order_id"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder,
		arg.Status,
		arg.ConfirmedAt,
		arg.CancelledAt,
		arg.DeliveredAt,
		arg.UserAddressID,
		arg.OrderID,
	)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.UserID,
		&i.UserAddressID,
		&i.TotalPrice,
		&i.Status,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.RefundedAt,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
