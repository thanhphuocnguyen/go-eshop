// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: order.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countOrders = `-- name: CountOrders :one
SELECT
    COUNT(*)
FROM
    orders
WHERE
    customer_id = $1 AND
    status = COALESCE($2, status) AND
    created_at >= COALESCE($3, created_at) AND
    created_at <= COALESCE($4, created_at)
`

type CountOrdersParams struct {
	CustomerID uuid.UUID          `json:"customer_id"`
	Status     NullOrderStatus    `json:"status"`
	StartDate  pgtype.Timestamptz `json:"start_date"`
	EndDate    pgtype.Timestamptz `json:"end_date"`
}

func (q *Queries) CountOrders(ctx context.Context, arg CountOrdersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders,
		arg.CustomerID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

type CreateBulkOrderItemsParams struct {
	ID                   uuid.UUID               `json:"id"`
	OrderID              uuid.UUID               `json:"order_id"`
	VariantID            uuid.UUID               `json:"variant_id"`
	Quantity             int16                   `json:"quantity"`
	PricePerUnitSnapshot pgtype.Numeric          `json:"price_per_unit_snapshot"`
	VariantSkuSnapshot   string                  `json:"variant_sku_snapshot"`
	ProductNameSnapshot  string                  `json:"product_name_snapshot"`
	LineTotalSnapshot    pgtype.Numeric          `json:"line_total_snapshot"`
	AttributesSnapshot   []AttributeDataSnapshot `json:"attributes_snapshot"`
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    id,
    customer_id,
    customer_email,
    customer_name,
    customer_phone,
    total_price,
    shipping_address
)
VALUES 
    ($1,$2,$3,$4, $5, $6, $7)
RETURNING id, customer_id, customer_email, customer_name, customer_phone, shipping_address, total_price, status, confirmed_at, delivered_at, cancelled_at, shipping_method, refunded_at, order_date, updated_at, created_at
`

type CreateOrderParams struct {
	ID              uuid.UUID               `json:"id"`
	CustomerID      uuid.UUID               `json:"customer_id"`
	CustomerEmail   string                  `json:"customer_email"`
	CustomerName    string                  `json:"customer_name"`
	CustomerPhone   string                  `json:"customer_phone"`
	TotalPrice      pgtype.Numeric          `json:"total_price"`
	ShippingAddress ShippingAddressSnapshot `json:"shipping_address"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.ID,
		arg.CustomerID,
		arg.CustomerEmail,
		arg.CustomerName,
		arg.CustomerPhone,
		arg.TotalPrice,
		arg.ShippingAddress,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.ShippingAddress,
		&i.TotalPrice,
		&i.Status,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.ShippingMethod,
		&i.RefundedAt,
		&i.OrderDate,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO
    order_items (id, order_id, variant_id, quantity, price_per_unit_snapshot, variant_sku_snapshot, product_name_snapshot, line_total_snapshot, attributes_snapshot)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, order_id, variant_id, quantity, price_per_unit_snapshot, line_total_snapshot, product_name_snapshot, variant_sku_snapshot, attributes_snapshot, created_at, updated_at
`

type CreateOrderItemParams struct {
	ID                   uuid.UUID               `json:"id"`
	OrderID              uuid.UUID               `json:"order_id"`
	VariantID            uuid.UUID               `json:"variant_id"`
	Quantity             int16                   `json:"quantity"`
	PricePerUnitSnapshot pgtype.Numeric          `json:"price_per_unit_snapshot"`
	VariantSkuSnapshot   string                  `json:"variant_sku_snapshot"`
	ProductNameSnapshot  string                  `json:"product_name_snapshot"`
	LineTotalSnapshot    pgtype.Numeric          `json:"line_total_snapshot"`
	AttributesSnapshot   []AttributeDataSnapshot `json:"attributes_snapshot"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.ID,
		arg.OrderID,
		arg.VariantID,
		arg.Quantity,
		arg.PricePerUnitSnapshot,
		arg.VariantSkuSnapshot,
		arg.ProductNameSnapshot,
		arg.LineTotalSnapshot,
		arg.AttributesSnapshot,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.VariantID,
		&i.Quantity,
		&i.PricePerUnitSnapshot,
		&i.LineTotalSnapshot,
		&i.ProductNameSnapshot,
		&i.VariantSkuSnapshot,
		&i.AttributesSnapshot,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM
    orders
WHERE
    id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrder, id)
	return err
}

const getOrder = `-- name: GetOrder :one
SELECT
    id, customer_id, customer_email, customer_name, customer_phone, shipping_address, total_price, status, confirmed_at, delivered_at, cancelled_at, shipping_method, refunded_at, order_date, updated_at, created_at
FROM
    orders
WHERE
    id = $1
LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.ShippingAddress,
		&i.TotalPrice,
		&i.Status,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.ShippingMethod,
		&i.RefundedAt,
		&i.OrderDate,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderProducts = `-- name: GetOrderProducts :many
SELECT
    oi.id, oi.order_id, oi.variant_id, oi.quantity, oi.price_per_unit_snapshot, oi.line_total_snapshot, oi.product_name_snapshot, oi.variant_sku_snapshot, oi.attributes_snapshot, oi.created_at, oi.updated_at,
    p.name as product_name,
    i.url as image_url
FROM
    order_items oi
JOIN
    product_variants pv ON oi.variant_id = pv.id
JOIN
    products p ON pv.product_id = p.id
LEFT JOIN image_assignments AS ia ON ia.entity_id = pv.id AND ia.entity_type = 'variant'
LEFT JOIN images AS i ON i.id = ia.image_id
WHERE
    oi.order_id = $1
`

type GetOrderProductsRow struct {
	ID                   uuid.UUID               `json:"id"`
	OrderID              uuid.UUID               `json:"order_id"`
	VariantID            uuid.UUID               `json:"variant_id"`
	Quantity             int16                   `json:"quantity"`
	PricePerUnitSnapshot pgtype.Numeric          `json:"price_per_unit_snapshot"`
	LineTotalSnapshot    pgtype.Numeric          `json:"line_total_snapshot"`
	ProductNameSnapshot  string                  `json:"product_name_snapshot"`
	VariantSkuSnapshot   string                  `json:"variant_sku_snapshot"`
	AttributesSnapshot   []AttributeDataSnapshot `json:"attributes_snapshot"`
	CreatedAt            time.Time               `json:"created_at"`
	UpdatedAt            time.Time               `json:"updated_at"`
	ProductName          string                  `json:"product_name"`
	ImageUrl             *string                 `json:"image_url"`
}

func (q *Queries) GetOrderProducts(ctx context.Context, orderID uuid.UUID) ([]GetOrderProductsRow, error) {
	rows, err := q.db.Query(ctx, getOrderProducts, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderProductsRow{}
	for rows.Next() {
		var i GetOrderProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.VariantID,
			&i.Quantity,
			&i.PricePerUnitSnapshot,
			&i.LineTotalSnapshot,
			&i.ProductNameSnapshot,
			&i.VariantSkuSnapshot,
			&i.AttributesSnapshot,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItems = `-- name: ListOrderItems :many
SELECT
    id, order_id, variant_id, quantity, price_per_unit_snapshot, line_total_snapshot, product_name_snapshot, variant_sku_snapshot, attributes_snapshot, created_at, updated_at
FROM
    order_items
WHERE
    order_id = $1
ORDER BY
    id
LIMIT $2
OFFSET $3
`

type ListOrderItemsParams struct {
	OrderID uuid.UUID `json:"order_id"`
	Limit   int64     `json:"limit"`
	Offset  int64     `json:"offset"`
}

func (q *Queries) ListOrderItems(ctx context.Context, arg ListOrderItemsParams) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, listOrderItems, arg.OrderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.VariantID,
			&i.Quantity,
			&i.PricePerUnitSnapshot,
			&i.LineTotalSnapshot,
			&i.ProductNameSnapshot,
			&i.VariantSkuSnapshot,
			&i.AttributesSnapshot,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many
SELECT
    ord.id, ord.customer_id, ord.customer_email, ord.customer_name, ord.customer_phone, ord.shipping_address, ord.total_price, ord.status, ord.confirmed_at, ord.delivered_at, ord.cancelled_at, ord.shipping_method, ord.refunded_at, ord.order_date, ord.updated_at, ord.created_at, pm.status as payment_status, COUNT(oit.id) as total_items
FROM
    orders ord
JOIN order_items oit ON ord.id = oit.id
LEFT JOIN payments pm ON ord.id = pm.id
WHERE
    customer_id = COALESCE($3, customer_id) AND
    ord.status = COALESCE($4, ord.status) AND
    ord.created_at >= COALESCE($5, ord.created_at) AND
    ord.created_at <= COALESCE($6, ord.created_at)
GROUP BY ord.id, pm.status
ORDER BY
    ord.created_at DESC
LIMIT $1
OFFSET $2
`

type ListOrdersParams struct {
	Limit      int64              `json:"limit"`
	Offset     int64              `json:"offset"`
	CustomerID pgtype.UUID        `json:"customer_id"`
	Status     NullOrderStatus    `json:"status"`
	StartDate  pgtype.Timestamptz `json:"start_date"`
	EndDate    pgtype.Timestamptz `json:"end_date"`
}

type ListOrdersRow struct {
	ID              uuid.UUID               `json:"id"`
	CustomerID      uuid.UUID               `json:"customer_id"`
	CustomerEmail   string                  `json:"customer_email"`
	CustomerName    string                  `json:"customer_name"`
	CustomerPhone   string                  `json:"customer_phone"`
	ShippingAddress ShippingAddressSnapshot `json:"shipping_address"`
	TotalPrice      pgtype.Numeric          `json:"total_price"`
	Status          OrderStatus             `json:"status"`
	ConfirmedAt     pgtype.Timestamptz      `json:"confirmed_at"`
	DeliveredAt     pgtype.Timestamptz      `json:"delivered_at"`
	CancelledAt     pgtype.Timestamptz      `json:"cancelled_at"`
	ShippingMethod  *string                 `json:"shipping_method"`
	RefundedAt      pgtype.Timestamptz      `json:"refunded_at"`
	OrderDate       time.Time               `json:"order_date"`
	UpdatedAt       time.Time               `json:"updated_at"`
	CreatedAt       time.Time               `json:"created_at"`
	PaymentStatus   NullPaymentStatus       `json:"payment_status"`
	TotalItems      int64                   `json:"total_items"`
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]ListOrdersRow, error) {
	rows, err := q.db.Query(ctx, listOrders,
		arg.Limit,
		arg.Offset,
		arg.CustomerID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrdersRow{}
	for rows.Next() {
		var i ListOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.CustomerEmail,
			&i.CustomerName,
			&i.CustomerPhone,
			&i.ShippingAddress,
			&i.TotalPrice,
			&i.Status,
			&i.ConfirmedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.ShippingMethod,
			&i.RefundedAt,
			&i.OrderDate,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.PaymentStatus,
			&i.TotalItems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE
    orders
SET
    status = coalesce($1, status),
    confirmed_at = coalesce($2, confirmed_at),
    cancelled_at = coalesce($3, cancelled_at),
    delivered_at = coalesce($4, delivered_at),
    updated_at = now()
WHERE
    id = $5
RETURNING id, customer_id, customer_email, customer_name, customer_phone, shipping_address, total_price, status, confirmed_at, delivered_at, cancelled_at, shipping_method, refunded_at, order_date, updated_at, created_at
`

type UpdateOrderParams struct {
	Status      NullOrderStatus    `json:"status"`
	ConfirmedAt pgtype.Timestamptz `json:"confirmed_at"`
	CancelledAt pgtype.Timestamptz `json:"cancelled_at"`
	DeliveredAt pgtype.Timestamptz `json:"delivered_at"`
	ID          uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder,
		arg.Status,
		arg.ConfirmedAt,
		arg.CancelledAt,
		arg.DeliveredAt,
		arg.ID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.ShippingAddress,
		&i.TotalPrice,
		&i.Status,
		&i.ConfirmedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.ShippingMethod,
		&i.RefundedAt,
		&i.OrderDate,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
