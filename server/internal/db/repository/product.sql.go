// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: product.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type AddBulkProductsParams struct {
	ID           uuid.UUID   `json:"id"`
	CategoryID   pgtype.UUID `json:"category_id"`
	CollectionID pgtype.UUID `json:"collection_id"`
	BrandID      pgtype.UUID `json:"brand_id"`
	Name         string      `json:"name"`
	Description  pgtype.Text `json:"description"`
}

const archiveProduct = `-- name: ArchiveProduct :exec
UPDATE
    products
SET
    is_active = $1,
    updated_at = NOW()
WHERE
    id = $2
`

type ArchiveProductParams struct {
	IsActive pgtype.Bool `json:"is_active"`
	ID       uuid.UUID   `json:"id"`
}

func (q *Queries) ArchiveProduct(ctx context.Context, arg ArchiveProductParams) error {
	_, err := q.db.Exec(ctx, archiveProduct, arg.IsActive, arg.ID)
	return err
}

const archiveProductVariant = `-- name: ArchiveProductVariant :exec
UPDATE
    product_variants
SET
    is_active = $1,
    updated_at = NOW()
WHERE
    id = $2
`

type ArchiveProductVariantParams struct {
	IsActive pgtype.Bool `json:"is_active"`
	ID       uuid.UUID   `json:"id"`
}

func (q *Queries) ArchiveProductVariant(ctx context.Context, arg ArchiveProductVariantParams) error {
	_, err := q.db.Exec(ctx, archiveProductVariant, arg.IsActive, arg.ID)
	return err
}

const countProducts = `-- name: CountProducts :one
SELECT
    COUNT(*)
FROM
    products
WHERE
    is_active = COALESCE($1, is_active) AND
    name ILIKE COALESCE($2, name)
`

type CountProductsParams struct {
	IsActive pgtype.Bool `json:"is_active"`
	Name     pgtype.Text `json:"name"`
}

func (q *Queries) CountProducts(ctx context.Context, arg CountProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts, arg.IsActive, arg.Name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

type CreateBulkProductVariantsParams struct {
	ID        uuid.UUID      `json:"id"`
	ProductID uuid.UUID      `json:"product_id"`
	Sku       string         `json:"sku"`
	Price     pgtype.Numeric `json:"price"`
	Stock     int32          `json:"stock"`
	Weight    pgtype.Numeric `json:"weight"`
	ImageUrl  pgtype.Text    `json:"image_url"`
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products 
    (id, name, description, base_price, base_sku, slug, brand_id, collection_id, category_id) 
VALUES 
    ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, name, description, base_price, base_sku, slug, is_active, category_id, collection_id, brand_id, created_at, updated_at
`

type CreateProductParams struct {
	ID           uuid.UUID      `json:"id"`
	Name         string         `json:"name"`
	Description  pgtype.Text    `json:"description"`
	BasePrice    pgtype.Numeric `json:"base_price"`
	BaseSku      pgtype.Text    `json:"base_sku"`
	Slug         string         `json:"slug"`
	BrandID      pgtype.UUID    `json:"brand_id"`
	CollectionID pgtype.UUID    `json:"collection_id"`
	CategoryID   pgtype.UUID    `json:"category_id"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.BasePrice,
		arg.BaseSku,
		arg.Slug,
		arg.BrandID,
		arg.CollectionID,
		arg.CategoryID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BasePrice,
		&i.BaseSku,
		&i.Slug,
		&i.IsActive,
		&i.CategoryID,
		&i.CollectionID,
		&i.BrandID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProductVariant = `-- name: CreateProductVariant :one
INSERT INTO product_variants
    (id, product_id, sku, price, stock, weight, image_url, image_id)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, product_id, sku, price, stock, weight, image_url, image_id, is_active, created_at, updated_at
`

type CreateProductVariantParams struct {
	ID        uuid.UUID      `json:"id"`
	ProductID uuid.UUID      `json:"product_id"`
	Sku       string         `json:"sku"`
	Price     pgtype.Numeric `json:"price"`
	Stock     int32          `json:"stock"`
	Weight    pgtype.Numeric `json:"weight"`
	ImageUrl  pgtype.Text    `json:"image_url"`
	ImageID   pgtype.Text    `json:"image_id"`
}

func (q *Queries) CreateProductVariant(ctx context.Context, arg CreateProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, createProductVariant,
		arg.ID,
		arg.ProductID,
		arg.Sku,
		arg.Price,
		arg.Stock,
		arg.Weight,
		arg.ImageUrl,
		arg.ImageID,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Price,
		&i.Stock,
		&i.Weight,
		&i.ImageUrl,
		&i.ImageID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM
    products
WHERE
    id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const deleteProductVariant = `-- name: DeleteProductVariant :exec
DELETE FROM
    product_variants
WHERE
    id = $1
`

func (q *Queries) DeleteProductVariant(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductVariant, id)
	return err
}

const getProductByID = `-- name: GetProductByID :one
SELECT
    products.id, products.name, products.description, products.base_price, products.base_sku, products.slug, products.is_active, products.category_id, products.collection_id, products.brand_id, products.created_at, products.updated_at
FROM
    products
WHERE
    products.id = $1 AND
    is_active = COALESCE($2, TRUE)
GROUP BY
    products.id
`

type GetProductByIDParams struct {
	ID       uuid.UUID   `json:"id"`
	IsActive pgtype.Bool `json:"is_active"`
}

func (q *Queries) GetProductByID(ctx context.Context, arg GetProductByIDParams) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByID, arg.ID, arg.IsActive)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BasePrice,
		&i.BaseSku,
		&i.Slug,
		&i.IsActive,
		&i.CategoryID,
		&i.CollectionID,
		&i.BrandID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductVariantByID = `-- name: GetProductVariantByID :one
SELECT
    product_variants.id, product_variants.product_id, product_variants.sku, product_variants.price, product_variants.stock, product_variants.weight, product_variants.image_url, product_variants.image_id, product_variants.is_active, product_variants.created_at, product_variants.updated_at
FROM
    product_variants
WHERE
    id = $1
`

func (q *Queries) GetProductVariantByID(ctx context.Context, id uuid.UUID) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, getProductVariantByID, id)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Price,
		&i.Stock,
		&i.Weight,
		&i.ImageUrl,
		&i.ImageID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductVariants = `-- name: GetProductVariants :many
SELECT
    p.id as product_id, p.name, p.description, p.base_price, p.base_sku, p.slug, p.updated_at, p.created_at, p.is_active,
    v.id as variant_id, v.sku as variant_sku, v.price as variant_price, v.stock as variant_stock, 
    v.weight as variant_weight, v.is_active as variant_is_active, v.image_url as variant_image_url, v.image_id as variant_image_id,
    a.id as attribute_id, a.name as attribute_name,
    av.id as attribute_value_id, av.value as attribute_value, av.display_order as attribute_display_order, 
    av.is_active as attribute_value_is_active, av.display_value as attribute_display_value,
    c.id AS category_id, c.name AS category_name,
    cl.id AS collection_id, cl.name AS collection_name,
    b.id AS brand_id, b.name AS brand_name,
    img.id AS image_id, img.url AS image_url, img.alt_text AS image_alt_text, 
    img.caption AS image_caption, img.mime_type AS image_mime_type, img.file_size AS image_file_size, 
    img.width AS image_width, img.height AS image_height, img.external_id AS image_external_id,
    ia.display_order AS image_display_order, ia.role AS image_role
FROM
    products p
LEFT JOIN product_variants as v ON p.id = v.product_id
LEFT JOIN variant_attribute_values as vav ON v.id = vav.variant_id
LEFT JOIN attribute_values as av ON vav.attribute_value_id = av.id
LEFT JOIN attributes as a ON av.attribute_id = a.id
LEFT JOIN categories as c ON p.category_id = c.id
LEFT JOIN collections as cl ON p.collection_id = cl.id
LEFT JOIN brands AS b ON p.brand_id = b.id
LEFT JOIN image_assignments AS ia ON p.id = ia.entity_id AND ia.entity_type = 'product'
LEFT JOIN images AS img ON img.id = ia.image_id
WHERE
    p.id = $1 AND
    p.is_active = COALESCE($2, TRUE)
ORDER BY
    p.id, v.id, a.id, av.display_order
`

type GetProductVariantsParams struct {
	ID       uuid.UUID   `json:"id"`
	IsActive pgtype.Bool `json:"is_active"`
}

type GetProductVariantsRow struct {
	ProductID              uuid.UUID      `json:"product_id"`
	Name                   string         `json:"name"`
	Description            pgtype.Text    `json:"description"`
	BasePrice              pgtype.Numeric `json:"base_price"`
	BaseSku                pgtype.Text    `json:"base_sku"`
	Slug                   string         `json:"slug"`
	UpdatedAt              time.Time      `json:"updated_at"`
	CreatedAt              time.Time      `json:"created_at"`
	IsActive               pgtype.Bool    `json:"is_active"`
	VariantID              pgtype.UUID    `json:"variant_id"`
	VariantSku             pgtype.Text    `json:"variant_sku"`
	VariantPrice           pgtype.Numeric `json:"variant_price"`
	VariantStock           pgtype.Int4    `json:"variant_stock"`
	VariantWeight          pgtype.Numeric `json:"variant_weight"`
	VariantIsActive        pgtype.Bool    `json:"variant_is_active"`
	VariantImageUrl        pgtype.Text    `json:"variant_image_url"`
	VariantImageID         pgtype.Text    `json:"variant_image_id"`
	AttributeID            pgtype.Int4    `json:"attribute_id"`
	AttributeName          pgtype.Text    `json:"attribute_name"`
	AttributeValueID       pgtype.Int4    `json:"attribute_value_id"`
	AttributeValue         pgtype.Text    `json:"attribute_value"`
	AttributeDisplayOrder  pgtype.Int2    `json:"attribute_display_order"`
	AttributeValueIsActive pgtype.Bool    `json:"attribute_value_is_active"`
	AttributeDisplayValue  pgtype.Text    `json:"attribute_display_value"`
	CategoryID             pgtype.UUID    `json:"category_id"`
	CategoryName           pgtype.Text    `json:"category_name"`
	CollectionID           pgtype.UUID    `json:"collection_id"`
	CollectionName         pgtype.Text    `json:"collection_name"`
	BrandID                pgtype.UUID    `json:"brand_id"`
	BrandName              pgtype.Text    `json:"brand_name"`
	ImageID                pgtype.Int4    `json:"image_id"`
	ImageUrl               pgtype.Text    `json:"image_url"`
	ImageAltText           pgtype.Text    `json:"image_alt_text"`
	ImageCaption           pgtype.Text    `json:"image_caption"`
	ImageMimeType          pgtype.Text    `json:"image_mime_type"`
	ImageFileSize          pgtype.Int8    `json:"image_file_size"`
	ImageWidth             pgtype.Int4    `json:"image_width"`
	ImageHeight            pgtype.Int4    `json:"image_height"`
	ImageExternalID        pgtype.Text    `json:"image_external_id"`
	ImageDisplayOrder      pgtype.Int2    `json:"image_display_order"`
	ImageRole              pgtype.Text    `json:"image_role"`
}

func (q *Queries) GetProductVariants(ctx context.Context, arg GetProductVariantsParams) ([]GetProductVariantsRow, error) {
	rows, err := q.db.Query(ctx, getProductVariants, arg.ID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductVariantsRow{}
	for rows.Next() {
		var i GetProductVariantsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.BasePrice,
			&i.BaseSku,
			&i.Slug,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.IsActive,
			&i.VariantID,
			&i.VariantSku,
			&i.VariantPrice,
			&i.VariantStock,
			&i.VariantWeight,
			&i.VariantIsActive,
			&i.VariantImageUrl,
			&i.VariantImageID,
			&i.AttributeID,
			&i.AttributeName,
			&i.AttributeValueID,
			&i.AttributeValue,
			&i.AttributeDisplayOrder,
			&i.AttributeValueIsActive,
			&i.AttributeDisplayValue,
			&i.CategoryID,
			&i.CategoryName,
			&i.CollectionID,
			&i.CollectionName,
			&i.BrandID,
			&i.BrandName,
			&i.ImageID,
			&i.ImageUrl,
			&i.ImageAltText,
			&i.ImageCaption,
			&i.ImageMimeType,
			&i.ImageFileSize,
			&i.ImageWidth,
			&i.ImageHeight,
			&i.ImageExternalID,
			&i.ImageDisplayOrder,
			&i.ImageRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductWithImage = `-- name: GetProductWithImage :one
SELECT
    products.id, products.name, products.description, products.base_price, products.base_sku, products.slug, products.is_active, products.category_id, products.collection_id, products.brand_id, products.created_at, products.updated_at,
    img.id AS image_id, img.url AS image_url
FROM
    products
LEFT JOIN image_assignments AS ia ON products.id = img.external_id AND img.entity_type = 'product'
LEFT JOIN images AS img ON img.id = ia.image_id
WHERE
    products.id = $1 AND
    is_active = COALESCE($2, false)
`

type GetProductWithImageParams struct {
	ID       uuid.UUID   `json:"id"`
	IsActive pgtype.Bool `json:"is_active"`
}

type GetProductWithImageRow struct {
	ID           uuid.UUID      `json:"id"`
	Name         string         `json:"name"`
	Description  pgtype.Text    `json:"description"`
	BasePrice    pgtype.Numeric `json:"base_price"`
	BaseSku      pgtype.Text    `json:"base_sku"`
	Slug         string         `json:"slug"`
	IsActive     pgtype.Bool    `json:"is_active"`
	CategoryID   pgtype.UUID    `json:"category_id"`
	CollectionID pgtype.UUID    `json:"collection_id"`
	BrandID      pgtype.UUID    `json:"brand_id"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	ImageID      pgtype.Int4    `json:"image_id"`
	ImageUrl     pgtype.Text    `json:"image_url"`
}

func (q *Queries) GetProductWithImage(ctx context.Context, arg GetProductWithImageParams) (GetProductWithImageRow, error) {
	row := q.db.QueryRow(ctx, getProductWithImage, arg.ID, arg.IsActive)
	var i GetProductWithImageRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BasePrice,
		&i.BaseSku,
		&i.Slug,
		&i.IsActive,
		&i.CategoryID,
		&i.CollectionID,
		&i.BrandID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImageID,
		&i.ImageUrl,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT
    p.id, p.name, p.description, p.base_price, p.base_sku, p.slug, p.is_active, p.category_id, p.collection_id, p.brand_id, p.created_at, p.updated_at,
    img.id AS image_id, img.url AS image_url,
    COUNT(v.id) AS variant_count
FROM products as p
LEFT JOIN product_variants as v ON p.id = v.product_id
LEFT JOIN (
    SELECT
        image_assignments.entity_id, image_assignments.image_id, image_assignments.display_order, image_assignments.role,
        images.id, images.url
    FROM image_assignments
    LEFT JOIN images ON images.id = image_assignments.image_id
    WHERE image_assignments.entity_type = 'product'
    LIMIT 1
) AS img ON p.id = img.entity_id
WHERE
    p.is_active = COALESCE($3, p.is_active) AND
    p.name ILIKE COALESCE($4, p.name) AND
    p.base_sku ILIKE COALESCE($5, p.base_sku)
GROUP BY
    p.id, img.id, img.url
ORDER BY
    p.id
LIMIT $1 OFFSET $2
`

type GetProductsParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	IsActive pgtype.Bool `json:"is_active"`
	Name     pgtype.Text `json:"name"`
	BaseSku  pgtype.Text `json:"base_sku"`
}

type GetProductsRow struct {
	ID           uuid.UUID      `json:"id"`
	Name         string         `json:"name"`
	Description  pgtype.Text    `json:"description"`
	BasePrice    pgtype.Numeric `json:"base_price"`
	BaseSku      pgtype.Text    `json:"base_sku"`
	Slug         string         `json:"slug"`
	IsActive     pgtype.Bool    `json:"is_active"`
	CategoryID   pgtype.UUID    `json:"category_id"`
	CollectionID pgtype.UUID    `json:"collection_id"`
	BrandID      pgtype.UUID    `json:"brand_id"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	ImageID      pgtype.Int4    `json:"image_id"`
	ImageUrl     pgtype.Text    `json:"image_url"`
	VariantCount int64          `json:"variant_count"`
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]GetProductsRow, error) {
	rows, err := q.db.Query(ctx, getProducts,
		arg.Limit,
		arg.Offset,
		arg.IsActive,
		arg.Name,
		arg.BaseSku,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsRow{}
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.BasePrice,
			&i.BaseSku,
			&i.Slug,
			&i.IsActive,
			&i.CategoryID,
			&i.CollectionID,
			&i.BrandID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ImageID,
			&i.ImageUrl,
			&i.VariantCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByBrandID = `-- name: GetProductsByBrandID :many
SELECT
    p.id, p.name, p.description, p.base_price, p.base_sku, p.slug, p.is_active, p.category_id, p.collection_id, p.brand_id, p.created_at, p.updated_at,
    img.id AS image_id,
    img.url AS image_url,
    MIN(p.base_price)::DECIMAL AS min_price,
    MAX(p.base_price)::DECIMAL AS max_price,
    MAX(p.base_price)::SMALLINT AS discount
FROM products AS p
LEFT JOIN image_assignments AS ia ON p.id = ia.entity_id AND ia.entity_type = 'product'
LEFT JOIN images AS img ON img.id = ia.image_id
WHERE
    p.is_active = COALESCE($4, is_active) AND
    p.name ILIKE COALESCE($5, name) AND
    p.base_sku ILIKE COALESCE($6, base_sku) AND
    p.brand_id = $1
GROUP BY
    p.id, img.id
ORDER BY
    p.id
LIMIT
    $2
OFFSET
    $3
`

type GetProductsByBrandIDParams struct {
	BrandID  pgtype.UUID `json:"brand_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	IsActive pgtype.Bool `json:"is_active"`
	Name     pgtype.Text `json:"name"`
	BaseSku  pgtype.Text `json:"base_sku"`
}

type GetProductsByBrandIDRow struct {
	ID           uuid.UUID      `json:"id"`
	Name         string         `json:"name"`
	Description  pgtype.Text    `json:"description"`
	BasePrice    pgtype.Numeric `json:"base_price"`
	BaseSku      pgtype.Text    `json:"base_sku"`
	Slug         string         `json:"slug"`
	IsActive     pgtype.Bool    `json:"is_active"`
	CategoryID   pgtype.UUID    `json:"category_id"`
	CollectionID pgtype.UUID    `json:"collection_id"`
	BrandID      pgtype.UUID    `json:"brand_id"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	ImageID      pgtype.Int4    `json:"image_id"`
	ImageUrl     pgtype.Text    `json:"image_url"`
	MinPrice     pgtype.Numeric `json:"min_price"`
	MaxPrice     pgtype.Numeric `json:"max_price"`
	Discount     int16          `json:"discount"`
}

func (q *Queries) GetProductsByBrandID(ctx context.Context, arg GetProductsByBrandIDParams) ([]GetProductsByBrandIDRow, error) {
	rows, err := q.db.Query(ctx, getProductsByBrandID,
		arg.BrandID,
		arg.Limit,
		arg.Offset,
		arg.IsActive,
		arg.Name,
		arg.BaseSku,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsByBrandIDRow{}
	for rows.Next() {
		var i GetProductsByBrandIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.BasePrice,
			&i.BaseSku,
			&i.Slug,
			&i.IsActive,
			&i.CategoryID,
			&i.CollectionID,
			&i.BrandID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ImageID,
			&i.ImageUrl,
			&i.MinPrice,
			&i.MaxPrice,
			&i.Discount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByCategoryID = `-- name: GetProductsByCategoryID :many
SELECT
    p.id, p.name, p.description, p.base_price, p.base_sku, p.slug, p.is_active, p.category_id, p.collection_id, p.brand_id, p.created_at, p.updated_at,
    img.id AS image_id, img.url AS image_url
FROM
    products AS p
LEFT JOIN image_assignments AS ia ON p.id = ia.entity_id AND ia.entity_type = 'product'
LEFT JOIN images AS img ON img.id = ia.image_id
WHERE
    p.is_active = COALESCE($4, is_active) AND
    p.name ILIKE COALESCE($5, name) AND
    p.base_sku ILIKE COALESCE($6, base_sku) AND
    p.category_id = $1
GROUP BY
    p.id, img.id
ORDER BY
    p.id
LIMIT
    $2
OFFSET
    $3
`

type GetProductsByCategoryIDParams struct {
	CategoryID pgtype.UUID `json:"category_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	IsActive   pgtype.Bool `json:"is_active"`
	Name       pgtype.Text `json:"name"`
	BaseSku    pgtype.Text `json:"base_sku"`
}

type GetProductsByCategoryIDRow struct {
	ID           uuid.UUID      `json:"id"`
	Name         string         `json:"name"`
	Description  pgtype.Text    `json:"description"`
	BasePrice    pgtype.Numeric `json:"base_price"`
	BaseSku      pgtype.Text    `json:"base_sku"`
	Slug         string         `json:"slug"`
	IsActive     pgtype.Bool    `json:"is_active"`
	CategoryID   pgtype.UUID    `json:"category_id"`
	CollectionID pgtype.UUID    `json:"collection_id"`
	BrandID      pgtype.UUID    `json:"brand_id"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	ImageID      pgtype.Int4    `json:"image_id"`
	ImageUrl     pgtype.Text    `json:"image_url"`
}

func (q *Queries) GetProductsByCategoryID(ctx context.Context, arg GetProductsByCategoryIDParams) ([]GetProductsByCategoryIDRow, error) {
	rows, err := q.db.Query(ctx, getProductsByCategoryID,
		arg.CategoryID,
		arg.Limit,
		arg.Offset,
		arg.IsActive,
		arg.Name,
		arg.BaseSku,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsByCategoryIDRow{}
	for rows.Next() {
		var i GetProductsByCategoryIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.BasePrice,
			&i.BaseSku,
			&i.Slug,
			&i.IsActive,
			&i.CategoryID,
			&i.CollectionID,
			&i.BrandID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ImageID,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByCollectionID = `-- name: GetProductsByCollectionID :many
SELECT
    p.id, p.name, p.description, p.base_price, p.base_sku, p.slug, p.is_active, p.category_id, p.collection_id, p.brand_id, p.created_at, p.updated_at,
    img.id AS image_id, img.url AS image_url
FROM products AS p
LEFT JOIN image_assignments AS ia ON p.id = ia.entity_id AND ia.entity_type = 'product'
LEFT JOIN images AS img ON img.id = ia.image_id
WHERE
    p.is_active = COALESCE($4, is_active) AND
    p.name ILIKE COALESCE($5, name) AND
    p.base_sku ILIKE COALESCE($6, base_sku) AND
    p.collection_id = $1
GROUP BY p.id, img.id
ORDER BY p.id
LIMIT $2
OFFSET $3
`

type GetProductsByCollectionIDParams struct {
	CollectionID pgtype.UUID `json:"collection_id"`
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
	IsActive     pgtype.Bool `json:"is_active"`
	Name         pgtype.Text `json:"name"`
	BaseSku      pgtype.Text `json:"base_sku"`
}

type GetProductsByCollectionIDRow struct {
	ID           uuid.UUID      `json:"id"`
	Name         string         `json:"name"`
	Description  pgtype.Text    `json:"description"`
	BasePrice    pgtype.Numeric `json:"base_price"`
	BaseSku      pgtype.Text    `json:"base_sku"`
	Slug         string         `json:"slug"`
	IsActive     pgtype.Bool    `json:"is_active"`
	CategoryID   pgtype.UUID    `json:"category_id"`
	CollectionID pgtype.UUID    `json:"collection_id"`
	BrandID      pgtype.UUID    `json:"brand_id"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	ImageID      pgtype.Int4    `json:"image_id"`
	ImageUrl     pgtype.Text    `json:"image_url"`
}

func (q *Queries) GetProductsByCollectionID(ctx context.Context, arg GetProductsByCollectionIDParams) ([]GetProductsByCollectionIDRow, error) {
	rows, err := q.db.Query(ctx, getProductsByCollectionID,
		arg.CollectionID,
		arg.Limit,
		arg.Offset,
		arg.IsActive,
		arg.Name,
		arg.BaseSku,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsByCollectionIDRow{}
	for rows.Next() {
		var i GetProductsByCollectionIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.BasePrice,
			&i.BaseSku,
			&i.Slug,
			&i.IsActive,
			&i.CategoryID,
			&i.CollectionID,
			&i.BrandID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ImageID,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE
    products
SET
    name = coalesce($1, name),
    description = coalesce($2, description),
    brand_id = coalesce($3, brand_id),
    collection_id = coalesce($4, collection_id),
    category_id = coalesce($5, category_id),
    slug = coalesce($6, slug),
    base_price = coalesce($7, base_price),
    base_sku = coalesce($8, base_sku),
    is_active = coalesce($9, is_active),
    updated_at = NOW()
WHERE
    id = $10
RETURNING id, name, description, base_price, base_sku, slug, is_active, category_id, collection_id, brand_id, created_at, updated_at
`

type UpdateProductParams struct {
	Name         pgtype.Text    `json:"name"`
	Description  pgtype.Text    `json:"description"`
	BrandID      pgtype.UUID    `json:"brand_id"`
	CollectionID pgtype.UUID    `json:"collection_id"`
	CategoryID   pgtype.UUID    `json:"category_id"`
	Slug         pgtype.Text    `json:"slug"`
	BasePrice    pgtype.Numeric `json:"base_price"`
	BaseSku      pgtype.Text    `json:"base_sku"`
	IsActive     pgtype.Bool    `json:"is_active"`
	ID           uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.Name,
		arg.Description,
		arg.BrandID,
		arg.CollectionID,
		arg.CategoryID,
		arg.Slug,
		arg.BasePrice,
		arg.BaseSku,
		arg.IsActive,
		arg.ID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BasePrice,
		&i.BaseSku,
		&i.Slug,
		&i.IsActive,
		&i.CategoryID,
		&i.CollectionID,
		&i.BrandID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductStock = `-- name: UpdateProductStock :one
UPDATE
    product_variants
SET
    stock = stock - $1
WHERE
    id = $2
RETURNING id, product_id, sku, price, stock, weight, image_url, image_id, is_active, created_at, updated_at
`

type UpdateProductStockParams struct {
	Stock int32     `json:"stock"`
	ID    uuid.UUID `json:"id"`
}

func (q *Queries) UpdateProductStock(ctx context.Context, arg UpdateProductStockParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, updateProductStock, arg.Stock, arg.ID)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Price,
		&i.Stock,
		&i.Weight,
		&i.ImageUrl,
		&i.ImageID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductVariant = `-- name: UpdateProductVariant :one
UPDATE
    product_variants
SET
    sku = coalesce($1, sku),
    price = coalesce($2, price),
    stock = coalesce($3, stock),
    weight = coalesce($4, weight),
    image_url = coalesce($5, image_url),
    image_id = coalesce($6, image_id),
    is_active = coalesce($7, is_active),
    updated_at = NOW()
WHERE
    id = $8
RETURNING id, product_id, sku, price, stock, weight, image_url, image_id, is_active, created_at, updated_at
`

type UpdateProductVariantParams struct {
	Sku      pgtype.Text    `json:"sku"`
	Price    pgtype.Numeric `json:"price"`
	Stock    pgtype.Int4    `json:"stock"`
	Weight   pgtype.Numeric `json:"weight"`
	ImageUrl pgtype.Text    `json:"image_url"`
	ImageID  pgtype.Text    `json:"image_id"`
	IsActive pgtype.Bool    `json:"is_active"`
	ID       uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateProductVariant(ctx context.Context, arg UpdateProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, updateProductVariant,
		arg.Sku,
		arg.Price,
		arg.Stock,
		arg.Weight,
		arg.ImageUrl,
		arg.ImageID,
		arg.IsActive,
		arg.ID,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Price,
		&i.Stock,
		&i.Weight,
		&i.ImageUrl,
		&i.ImageID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
