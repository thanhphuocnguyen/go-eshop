// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: collection.sql

package repository

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCollections = `-- name: CountCollections :one
SELECT count(*)
FROM collections
WHERE collection_id = COALESCE($1, collection_id)
`

func (q *Queries) CountCollections(ctx context.Context, collectionID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countCollections, collectionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCollection = `-- name: CreateCollection :one
INSERT INTO collections (name, description, image_url)
VALUES (
    $1,
    $2,
    $3
)
RETURNING collection_id, name, image_url, description, created_at, updated_at
`

type CreateCollectionParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	ImageUrl    pgtype.Text `json:"image_url"`
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, createCollection, arg.Name, arg.Description, arg.ImageUrl)
	var i Collection
	err := row.Scan(
		&i.CollectionID,
		&i.Name,
		&i.ImageUrl,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM collections WHERE collection_id = $1
`

func (q *Queries) DeleteCollection(ctx context.Context, collectionID int32) error {
	_, err := q.db.Exec(ctx, deleteCollection, collectionID)
	return err
}

const getCollectionByID = `-- name: GetCollectionByID :one
SELECT c.collection_id, c.name, c.image_url, c.description, c.created_at, c.updated_at FROM collections c WHERE c.collection_id = $1 LIMIT 1
`

func (q *Queries) GetCollectionByID(ctx context.Context, collectionID int32) (Collection, error) {
	row := q.db.QueryRow(ctx, getCollectionByID, collectionID)
	var i Collection
	err := row.Scan(
		&i.CollectionID,
		&i.Name,
		&i.ImageUrl,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCollections = `-- name: GetCollections :many
SELECT 
    c.collection_id, c.name, c.image_url, c.description, c.created_at, c.updated_at, 
    p.name as product_name, p.product_id, p.description,
    MIN(pv.price) as price_from, 
    MAX(pv.price) as price_to, 
    MAX(pv.discount) as discount, 
    MIN(pv.stock_quantity) as stock_quantity, 
    COUNT(pv.variant_id) as variant_count,
    img.image_id, img.image_url
FROM collections AS c
LEFT JOIN products AS p ON c.collection_id = p.collection_id
LEFT JOIN product_variants AS pv ON p.product_id = pv.product_id
LEFT JOIN images AS img ON p.product_id = img.product_id
GROUP BY c.collection_id, p.product_id, img.image_id, img.image_url
LIMIT $1 OFFSET $2
`

type GetCollectionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetCollectionsRow struct {
	CollectionID  int32       `json:"collection_id"`
	Name          string      `json:"name"`
	ImageUrl      pgtype.Text `json:"image_url"`
	Description   pgtype.Text `json:"description"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	ProductName   pgtype.Text `json:"product_name"`
	ProductID     pgtype.UUID `json:"product_id"`
	Description_2 pgtype.Text `json:"description_2"`
	PriceFrom     interface{} `json:"price_from"`
	PriceTo       interface{} `json:"price_to"`
	Discount      interface{} `json:"discount"`
	StockQuantity interface{} `json:"stock_quantity"`
	VariantCount  int64       `json:"variant_count"`
	ImageID       pgtype.Int4 `json:"image_id"`
	ImageUrl_2    pgtype.Text `json:"image_url_2"`
}

func (q *Queries) GetCollections(ctx context.Context, arg GetCollectionsParams) ([]GetCollectionsRow, error) {
	rows, err := q.db.Query(ctx, getCollections, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionsRow
	for rows.Next() {
		var i GetCollectionsRow
		if err := rows.Scan(
			&i.CollectionID,
			&i.Name,
			&i.ImageUrl,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductID,
			&i.Description_2,
			&i.PriceFrom,
			&i.PriceTo,
			&i.Discount,
			&i.StockQuantity,
			&i.VariantCount,
			&i.ImageID,
			&i.ImageUrl_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionsByIDs = `-- name: GetCollectionsByIDs :many
SELECT 
    c.collection_id, c.name, c.image_url, c.description, c.created_at, c.updated_at, 
    p.name as product_name, p.product_id, p.description,
    MIN(pv.price) as price_from, 
    MAX(pv.price) as price_to, 
    MAX(pv.discount) as discount, 
    MIN(pv.stock_quantity) as stock_quantity, 
    COUNT(pv.variant_id) as variant_count,
    img.image_id, img.image_url
FROM collections AS c
LEFT JOIN products AS p ON c.collection_id = p.collection_id
LEFT JOIN product_variants AS pv ON p.product_id = pv.product_id
LEFT JOIN images AS img ON p.product_id = img.product_id
WHERE c.collection_id = ANY($3::int[])
GROUP BY c.collection_id, p.product_id, img.image_id, img.image_url
LIMIT $1 OFFSET $2
`

type GetCollectionsByIDsParams struct {
	Limit         int32   `json:"limit"`
	Offset        int32   `json:"offset"`
	CollectionIds []int32 `json:"collection_ids"`
}

type GetCollectionsByIDsRow struct {
	CollectionID  int32       `json:"collection_id"`
	Name          string      `json:"name"`
	ImageUrl      pgtype.Text `json:"image_url"`
	Description   pgtype.Text `json:"description"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	ProductName   pgtype.Text `json:"product_name"`
	ProductID     pgtype.UUID `json:"product_id"`
	Description_2 pgtype.Text `json:"description_2"`
	PriceFrom     interface{} `json:"price_from"`
	PriceTo       interface{} `json:"price_to"`
	Discount      interface{} `json:"discount"`
	StockQuantity interface{} `json:"stock_quantity"`
	VariantCount  int64       `json:"variant_count"`
	ImageID       pgtype.Int4 `json:"image_id"`
	ImageUrl_2    pgtype.Text `json:"image_url_2"`
}

func (q *Queries) GetCollectionsByIDs(ctx context.Context, arg GetCollectionsByIDsParams) ([]GetCollectionsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getCollectionsByIDs, arg.Limit, arg.Offset, arg.CollectionIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionsByIDsRow
	for rows.Next() {
		var i GetCollectionsByIDsRow
		if err := rows.Scan(
			&i.CollectionID,
			&i.Name,
			&i.ImageUrl,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductID,
			&i.Description_2,
			&i.PriceFrom,
			&i.PriceTo,
			&i.Discount,
			&i.StockQuantity,
			&i.VariantCount,
			&i.ImageID,
			&i.ImageUrl_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type SeedCollectionsParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	ImageUrl    pgtype.Text `json:"image_url"`
}

const updateCollectionWith = `-- name: UpdateCollectionWith :one
UPDATE collections
SET 
    name = COALESCE($2, name), 
    image_url = COALESCE($3, image_url), 
    description = COALESCE($4, description),
    updated_at = now()
WHERE collection_id = $1
RETURNING collection_id, name, image_url, description, created_at, updated_at
`

type UpdateCollectionWithParams struct {
	CollectionID int32       `json:"collection_id"`
	Name         pgtype.Text `json:"name"`
	ImageUrl     pgtype.Text `json:"image_url"`
	Description  pgtype.Text `json:"description"`
}

func (q *Queries) UpdateCollectionWith(ctx context.Context, arg UpdateCollectionWithParams) (Collection, error) {
	row := q.db.QueryRow(ctx, updateCollectionWith,
		arg.CollectionID,
		arg.Name,
		arg.ImageUrl,
		arg.Description,
	)
	var i Collection
	err := row.Scan(
		&i.CollectionID,
		&i.Name,
		&i.ImageUrl,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
